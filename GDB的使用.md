# GDB的使用

## 代码

```cpp
// test_gdb.cpp
#include <iostream>

int main() {
   std::cout << "hello gdb!" << std::endl;
   return 0;
}
```



## 使用 GDB 编译

```shell
g++ -g test_gdb.cpp
```



## 使用 GDB 运行可执行文件

```shell
g++ -g ./a.out #进入到GDB调试环境中
```



## 使用 GDB 命令进行调试

最常见的GDB命令如下：

`break`          `edit`

`run`              `list`

`bt`		`step`			

`print`          `help`

`c`                  `quit`

`next`

```shell
#在GDB中每一种命令都支持简写成第一个字母

# 运行程序run，或者简写成： r
run #r也可以

# 退出GDB,或者简写成：q
quit #q也可以

# 打断点break or b
break main #在main函数中的第一行处打一个断点
break (数字) # 在某一行处打断点

# 查看源代码list or l
list 

# 查看哪些地方打了断点
info break #info b

# 一步一步往下调试 next or n
next 

# 查看元素的值 print or p
print arr[0]
print s
# 打印地址
print &arr
print &arr[0]

#step进入到函数里面进行调试
```

### 补充

```shell
 Here are some of the most frequently needed GDB commands:

       break [file:][function|line]
           Set a breakpoint at function or line (in file).

       run [arglist]
           Start your program (with arglist, if specified).

       bt  Backtrace: display the program stack.

       print expr
           Display the value of an expression.

       c   Continue running your program (after stopping, e.g. at a breakpoint).

       next
           Execute next program line (after stopping); step over any function calls in the line.

       edit [file:]function
           look at the program line where it is presently stopped.

       list [file:]function
           type the text of the program in the vicinity of where it is presently stopped.

       step
           Execute next program line (after stopping); step into any function calls in the line.

       help [name]
           Show information about GDB command name, or general information about using GDB.

       quit
       exit
           Exit from GDB.
```



### 技巧

1. **我们可以使用shell + 命令 来执行一些终端的命令**

```shell
(gdb) shell cat hello.txt
```



2. **打印日志**

```shell
# 这里会生成一个 gdb.txt 文件在对应的目录下，里面就是打印的一些日志信息
(gdb) set logging on
```



3. **watchpoint 和 catchpoint**

watchpoint：观察一个变量是否变化

```shell
# 观察变量是否变化
print &i # 记录变量地址
watch (i的地址) # 给变量设置一个观察点
info watch # 查看观察点列表
#后续如果i的值发生变化，会输出旧值和新值
Old Value = 0
New Value = 1 
```



catchpoint：查看异常



## 调试core文件

```cpp
// 错误代码
#include <iostream>

int main() {
	int *ptr = nullptr;
	*ptr = 10;
	return 0;
	
}

./a.out 抛出Segmentation fault
```



**shell 会对不同用户进行一些限制，因此core文件不会默认生成**



**ulimit -a**

```shell
lsj@LAPTOP-67QOKF5T:~/code$ ulimit -a
real-time non-blocking time  (microseconds, -R) unlimited
core file size              (blocks, -c) 0
data seg size               (kbytes, -d) unlimited
scheduling priority                 (-e) 0
file size                   (blocks, -f) unlimited
pending signals                     (-i) 50634
max locked memory           (kbytes, -l) 64
max memory size             (kbytes, -m) unlimited
open files                          (-n) 4096
pipe size                (512 bytes, -p) 8
POSIX message queues         (bytes, -q) 819200
real-time priority                  (-r) 0
stack size                  (kbytes, -s) 8192
cpu time                   (seconds, -t) unlimited
max user processes                  (-u) 50634
virtual memory              (kbytes, -v) unlimited
file locks                          (-x) unlimited
```



**修改core文件的限制**

```shell
ulimit -c unlimited
```



**进一步查看**

gdb 二进制文件 core文件

```shell
gdb ./a.out core

Core was generated by `./a.out'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00005572a1d0717d in main () at test_error.cpp:5
5               *ptr = 10;
```



## 调试正在运行的文件

```shell
# 后台运行a.out
./a.out &
gdb -p pid
```

