## C++ 11新特性



#### 一. 原始字面量(Raw String Literals)：

它允许在字符串中直接包含换行符，反斜杠等特殊字符，而不需要进行转移。



**基本语法：**

```cpp
// 这里delimiter两边必须一样，相当于注释的作用
R"delimiter(raw_characters)delimiter"
```

1. R 表示这是一个原始字符串

2. delimiter 是可选的定界符，可以是空（此时语法为 R"(...)"）

3. raw_characters 是字符串的实际内容

**主要特点:**

1. 无需转义特殊字符：在原始字符串中，反斜杠\、引号"等字符都按字面意义处理

   ```cpp
   std::string path = R"(C:\Program Files\MyApp)";  // 不需要转义反斜杠
   ```

   

2. 保留换行和缩进：字符串中的换行符和缩进都会被保留

   ```cpp
   std::string text = R"(
       Hello,
       This is a multi-line
       raw string literal.
   )";
   ```

   

3. 可自定义定界符：当字符串本身包含)"时，可以使用自定义定界符来避免冲突

```cpp
std::string regex = R"delimiter((\w+)=("([^"]*)")delimiter";
```



#### 二. `nullptr`

用于表示空指针常量，它解决了传统NULL宏带来的一些问题。

![image-20250413202229871](C:\Users\刘世杰\AppData\Roaming\Typora\typora-user-images\image-20250413202229871.png)

**为什么需要`nullptr`？**

在C++98/03中，通常使用NULL宏表示空指针，但NULL通常定义为0或(void*)0，这会导致一些问题：

1. **类型安全问题**：NULL实际上是整数0，可以隐式转换为任何指针类型，也可能与整数类型混淆

   ```cpp
   void func(int);
   void func(char*);
   
   func(NULL);  // 调用哪个？可能调用func(int)而不是预期的func(char*)
   ```

   

2. **模板推导问题**：在模板中，NULL的类型推导可能不符合预期



**`nullptr`的特性：**

1. **明确的指针类型**：`nullptr`的类型是std::nullptr_t，可以隐式转换为任何指针类型

```cpp
int* ptr = nullptr;
char* str = nullptr;
```

2. __不会与整数类型混淆：`__nullptr`不能转换为整数类型

```cpp
int i = nullptr;  // 错误
```

3. __解决函数重载问题：__

```cpp
void func(int);
void func(char*);

func(nullptr);  // 明确调用func(char*)
```

4. __模板友好：__在模板编程中能正确推导指针类型

```cpp
template<typename T>
void f(T* ptr);

f(nullptr);  // T被推导为std::nullptr_t
```

__使用实例：__

```cpp
// 函数重载示例
void foo(int) { std::cout << "foo(int)\n"; }
void foo(char*) { std::cout << "foo(char*)\n"; }

foo(0);         // 调用foo(int)
foo(nullptr);   // 调用foo(char*)

// 指针初始化
int* p1 = nullptr;
if (p1 == nullptr) { /* ... */ }

// 作为函数参数
void bar(std::string* s = nullptr) {
    if (s != nullptr) { /* ... */ }
}
```



#### 三.` constexpr`修饰常量表达式

用于指定变量或函数可以在编译时求值，从而支持编译期计算和优化。



__基本概念：__

__`constexpr`__表示"常量表达式"(constant expression)，主要有两种用途：

1. 声明常量表达式变量

2. 声明常量表达式函数



__`constexpr`变量:__
`constexpr`变量必须在编译时就确定其值：



__与`cons`t的区别：__

1. `const`只表示"不可修改"，但不一定是编译期常量

2. `constexpr`一定是编译期常量

```cpp
constexpr int size = 10;              // 编译时常量
constexpr double pi = 3.1415926535;   // 编译时常量
```



__`constexpr`函数:__

`constexpr`函数可以在编译时被求值，前提是传入的参数也是编译时常量：



__`constexpr`函数限制(C++11)：__

1. 函数体必须只包含单个return语句(不能有循环、分支等)

2. 只能调用其他`constexpr`函数

3. 只能使用全局变量或字面量类型的参数

```cpp
constexpr int factorial(int n) {
    return n <= 1 ? 1 : n * factorial(n - 1);
}

int main() {
    constexpr int fact5 = factorial(5);  // 编译时计算，结果为120
    int n = 5;
    int fact_n = factorial(n);          // 运行时计算
}
```



__主要用途:__

1. 编译期计算：

   ```cpp
   constexpr int array_size = 10;
   int arr[array_size];  // 数组大小在编译时确定
   ```

2. 替代宏常量：

   ```cpp
   constexpr double gravity = 9.8;  // 比#define更安全
   ```

3. 模板元编程：

   ```cpp
   template<int N>
   struct Factorial {
       static constexpr int value = N * Factorial<N-1>::value;
   };
   ```

4. 与静态断言配合：

   ```cpp
   static_assert(factorial(5) == 120, "Factorial error");
   ```

   

__C++11 vs C++14的`constexpr`:__
在C++14中，`constexpr`函数的限制大大放宽：

1. 允许局部变量

2. 允许循环和分支语句

3. 允许修改生命周期在函数内的对象



__注意事项:__

1. `constexpr`变量必须立即初始化

2. `constexpr`函数在编译期调用时才在编译期求值，否则在运行时求值

3. 不是所有类型都可以是`constexpr`，必须是字面类型(literal type)



#### 三. auto

用于自动类型推导，它可以让编译器根据初始化表达式自动推导变量的类型，从而简化代码编写。

![image-20250413211924051](C:\Users\刘世杰\AppData\Roaming\Typora\typora-user-images\image-20250413211924051.png)

__基本用法:__

1. 变量声明:

   ```cpp
   auto x = 5;          // x 被推导为 int
   auto y = 3.14;       // y 被推导为 double
   auto str = "hello";  // str 被推导为 const char*
   ```

2. 复杂类型简化:

   ```cpp
   std::vector<std::string> names = {"Alice", "Bob", "Charlie"};
   
   // 传统写法
   std::vector<std::string>::iterator it = names.begin();
   
   // 使用 auto 简化
   auto it = names.begin();  // 自动推导为 std::vector<std::string>::iterator
   ```

   

__主要优势:__

1. 减少冗长类型名：特别是模板类型和嵌套类型

   ```cpp
   std::unordered_map<std::string, std::vector<int>> complexMap;
   
   // 不使用 auto
   std::pair<const std::string, std::vector<int>>& entry = *complexMap.begin();
   
   // 使用 auto
   auto& entry = *complexMap.begin();
   ```

   

2. 泛型编程更简洁：

   ```cpp
   template <typename T, typename U>
   auto add(T t, U u) -> decltype(t + u) {
       return t + u;
   }
   ```

   

3. 支持lambda表达式存储：

   ```cpp
   auto lambda = [](int x) { return x * 2; };
   ```

__使用场景:__
1. 迭代器简化

   ```cpp
   std::vector<int> vec = {1, 2, 3};
   for (auto it = vec.begin(); it != vec.end(); ++it) {
       std::cout << *it << std::endl;
   }
   ```

   

2. 范围for循环

   ```cpp
   for (auto& num : vec) {  // 自动推导元素类型
       num *= 2;
   }
   ```

   

3. 函数返回类型推导 (C++14扩展)

   ```cpp
   auto multiply(double a, double b) {
       return a * b;  // 返回类型自动推导为 double
   }
   ```

__注意事项:__

1. 必须初始化：auto 变量必须初始化

2. 引用和`const`限定：

3. 数组退化：

4. 类型精确控制：

   （1）使用 `auto* `确保指针类型

   （2）使用 `const auto` 确保常量性

​	__当变量不是指针或者引用类型时，推导的结果中不会保留`const`，volatile关键字__

​	__当变量是指针或者引用类型时，推导的结果中会保留`const`，volatile关键字__

5. 一些限制：

   （1）不能作为函数参数使用

   （2）不能用于类的非静态成员变量的初始化

   （3）不能使用auto关键字定义数组 (auto t = array,这里t被推导成数组指针)

   （4）无法使用auto推导出模板参数



#### 四. decltype

`decltype` 是 C++11 引入的类型推导关键字，用于**查询表达式的类型**。它可以在编译时推导出表达式的确切类型，包括保留引用和 `const` 限定符。

#### 基本语法:

```cpp
decltype(expression) variable;
```

#### 推断规则：

规则 1：简单变量名，保留所有类型信息（包括引用和 cv 限定符）

规则 2：非变量名表达式
	编译器会检查表达式的结果：

​	1. 如果表达式是左值 → T&

​	2. 如果表达式是将亡值（xvalue）→ T&&

​	3. 如果表达式是纯右值（prvalue）→ T

#### 主要特性:

1. **精确类型推导**：完全保留表达式的类型信息，包括引用和 `const` 限定
   
   ```cpp
   int i = 42;
   const int& r = i;
   decltype(r) x = i;  // x 的类型是 const int&
   ```
   
2. **与 `auto` 的区别**：
   - `auto` 忽略顶层 `const` 和引用（除非显式指定）
   - `decltype` 完全保留表达式的类型 （如果某个函数f返回一个右值，那么使用decltype(f)进行推导时，会将const忽略掉）

   ```cpp
   const int ci = 0;
   auto a = ci;        // a 是 int (忽略顶层const)
   decltype(ci) b = 0; // b 是 const int
   ```

#### 使用场景

1. 函数返回类型推导

```cpp
template <typename T, typename U>
auto add(T t, U u) -> decltype(t + u) {
    return t + u;
}
```

2. 元编程和类型萃取

```cpp
template <typename T>
void print_type() {
    std::cout << typeid(decltype(T())).name() << std::endl;
}
```

3. 复杂表达式类型捕获

```cpp
std::vector<int> vec;
decltype(vec.size()) size = vec.size();  // 正确获取size_type类型
```

4. Lambda表达式类型捕获

```cpp
auto lambda = [](int x) { return x * 1.5; };
decltype(lambda) copy = lambda;  // 精确复制lambda类型
```

特殊规则

1. **变量名**：给出变量的声明类型（包括引用）
   ```cpp
   int i = 0;
   decltype(i) x;  // x 是 int
   ```

2. **表达式**：给出表达式结果的类型
   ```cpp
   int i = 0;
   decltype((i)) y = i;  // y 是 int& (因为(i)是左值表达式)
   ```

3. **函数调用**：给出函数的返回类型
   ```cpp
   decltype(std::declval<std::string>().size()) len;  // len是size_type
   ```

#### 与 `auto` 的对比

| 特性        | `decltype`   | `auto`               |
| ----------- | ------------ | -------------------- |
| 引用保留    | 总是保留     | 需要显式指定 (auto&) |
| `const`保留 | 总是保留     | 顶层`const`被忽略    |
| 数组类型    | 保留数组类型 | 退化为指针           |
| 表达式求值  | 不实际求值   | 需要初始化表达式     |
| 主要用途    | 类型查询     | 变量类型推导         |

#### 实际应用示例

1. 通用函数返回类型

```cpp
template <typename Container>
auto getFirst(Container& c) -> decltype(c[0]) {
    return c[0];
}
```

2. 类型萃取

```cpp
template <typename T>
using RemoveReference = typename std::remove_reference<decltype(std::declval<T>())>::type;
```

3. SFINAE 应用

```cpp
template <typename T>
auto check_has_size(T& t) -> decltype(t.size(), std::true_type{});
```

注意事项

1. `decltype` 不计算表达式的值，只分析类型
2. 对于变量名和表达式有不同的推导规则
3. 在模板元编程中特别有用
4. C++14 引入了 `decltype(auto)` 进一步简化某些用法

`decltype` 为 C++ 提供了强大的编译时类型查询能力，是模板编程和泛型编程中的重要工具，特别是在需要精确控制类型信息的场景下非常有用。



#### 五. volatile

`volatile` 是 C++ 中的一个类型修饰符，用于告诉编译器该变量可能会在程序控制之外被意外修改，从而防止编译器对该变量的访问进行优化。

#### 基本作用:

`volatile` 的主要作用是：
1. **禁止编译器优化**：防止编译器对 volatile 变量的读写操作进行优化（如删除"冗余"读取或缓存值）

2. **保证访问顺序**：确保对 volatile 变量的操作按照代码顺序执行

3. **用于特殊内存**：标记那些可能被硬件、中断服务程序或多线程修改的内存

   

#### 基本语法:

```cpp
volatile int counter;          // volatile变量
volatile int* pToVolatile;     // 指向volatile数据的指针
int* volatile volatilePtr;     // volatile指针(指针本身是volatile)
volatile int* volatile pBoth; // 指针和指向的数据都是volatile
```



#### 典型使用场景:

1. 硬件寄存器访问

```cpp
// 假设0x1234是一个硬件寄存器地址
volatile uint32_t* const hardwareReg = reinterpret_cast<uint32_t*>(0x1234);

// 每次读取都会实际访问硬件寄存器
uint32_t value = *hardwareReg;
```

2. 多线程共享变量 (注意：volatile 不能替代原子操作或互斥锁)

```cpp
volatile bool flag = false;

// 线程1
void thread1() {
    while(!flag) {} // 等待flag变为true
    // 执行操作
}

// 线程2
void thread2() {
    // 做一些工作...
    flag = true; // 通知线程1
}
```

3. 信号处理程序中的变量

```cpp
volatile sig_atomic_t signalReceived = 0;

void signalHandler(int) {
    signalReceived = 1;
}

int main() {
    signal(SIGINT, signalHandler);
    while(!signalReceived) {
        // 正常处理
    }
    // 收到信号后的处理
}
```



#### 与 `const` 的结合使用

`volatile` 可以与 `const` 一起使用，表示变量本身不应该被程序修改，但可能被外部因素修改：

```cpp
const volatile uint32_t* readOnlyReg = ...;
// 程序不能修改 *readOnlyReg，但它可能被硬件改变
```



#### 重要注意事项

1. **不是线程安全保证**：
   - `volatile` **不**提供原子性保证
   - `volatile` **不**解决内存可见性问题
   - 在多线程编程中，应该使用 `std::atomic` 或互斥锁

2. **与优化相关**：
   ```cpp
   int normalVar = 0;
   volatile int volatileVar = 0;
   
   normalVar = 1;    // 编译器可能优化掉这条语句如果没有后续使用
   volatileVar = 1;  // 一定会执行，不会被优化
   ```

3. **访问保证**：
   - 每次访问 volatile 变量都会从内存中读取或写入
   - 操作不会被重新排序（相对于其他 volatile 操作）



#### volatile 与 constexpr

`volatile` 和 `constexpr` 是互斥的，因为：
- `constexpr` 表示编译时常量
- `volatile` 表示运行时可能被意外修改

```cpp
// 错误：不能同时使用
constexpr volatile int x = 10; 
```



#### 现代C++中的替代方案

1. 对于硬件访问：考虑使用特定于平台的 memory-mapped I/O 库
2. 对于多线程：使用 `<atomic>` 头文件中的 `std::atomic`
3. 对于信号处理：仍然需要 `volatile sig_atomic_t`



#### 总结

`volatile` 的正确使用场景：
- 内存映射的硬件寄存器
- 被中断服务程序修改的变量
- 被不同线程访问且平台保证原子性的基本类型变量
- 信号处理程序中使用的全局变量

在大多数常规编程中，特别是多线程编程，应该优先考虑使用 `std::atomic` 而不是 `volatile`。



### 六. 返回值类型后置语法

返回值类型后置（Trailing Return Type）是 C++11 引入的一种函数声明语法，它允许将函数的返回类型放在参数列表之后，使用 `->` 符号引导。



#### 基本语法

```cpp
auto 函数名(参数列表) -> 返回类型 {
    // 函数体
}
```



#### 主要用途

1. 配合 `decltype` 使用（解决模板编程中类型依赖问题）

```cpp
template <typename T, typename U>
auto add(T x, U y) -> decltype(x + y) {
    return x + y;
}
```

2. 简化复杂返回类型的声明

```cpp
// 传统方式
std::vector<int>::iterator getIter(std::vector<int>& v);

// 使用后置返回类型
auto getIter(std::vector<int>& v) -> std::vector<int>::iterator;
```

3. Lambda 表达式的返回类型指定

```cpp
auto lambda = [](int x) -> double {
    return x * 1.5;
};
```



#### 优势特点

1. **解决类型依赖问题**：当返回类型依赖于参数类型时特别有用
   
   ```cpp
   template <typename Container>
   auto begin(Container& c) -> decltype(c.begin()) {
       return c.begin();
   }
   ```
   
2. **提高可读性**：对于复杂返回类型更清晰
   ```cpp
   auto (*getFunc())(int, int) -> int;  // 传统方式难以阅读
   auto getFunc() -> int(*)(int, int);  // 后置方式更清晰
   ```

3. **统一语法**：与 lambda 表达式语法保持一致



#### 实际应用示例

1. 模板函数中的类型推导

```cpp
template <typename T>
auto process(T data) -> typename T::value_type {
    return *data.begin();
}
```

2. 返回数组引用

```cpp
auto getArray() -> int(&)[10] {
    static int arr[10];
    return arr;
}
```

3. 复杂函数指针返回

```cpp
auto getCallback() -> void(*)(int, const std::string&) {
    return [](int, const std::string&){ /*...*/ };
}
```



#### 注意事项

1. 必须使用 `auto` 作为前导关键字
2. 在类定义中同样适用
   ```cpp
   class MyClass {
   public:
       auto method() -> int;
   };
   ```
3. C++14 开始可以省略后置返回类型（使用 `auto` 自动推导），但在需要明确类型或类型依赖参数时仍需使用



#### 与 C++14 自动返回类型推导的区别

| 特性       | 返回值类型后置        | C++14 自动返回类型推导         |
| ---------- | --------------------- | ------------------------------ |
| 语法       | `auto func() -> type` | `auto func()`                  |
| 类型明确性 | 显式指定              | 由编译器推导                   |
| 模板依赖   | 必须使用              | 不能用于依赖模板参数的返回类型 |
| 可读性     | 复杂类型更清晰        | 简单类型更简洁                 |

返回值类型后置语法是现代 C++ 中非常重要的特性，特别是在模板编程和泛型编程中，它解决了返回类型依赖参数类型时的声明问题，使代码更加灵活和可维护。



### 七. `final`

`final` 是 C++11 引入的一个重要关键字，用于限制类或虚函数的进一步继承或重写。它提供了两种主要用途：



#### 1. 用于类（禁止继承）

当 `final` 用于类定义时，表示该类不能被继承。

#### 语法：
```cpp
class ClassName final {
    // 类成员
};
```

#### 示例：
```cpp
class Base final {
    // ...
};

// 错误：不能继承 final 类
class Derived : public Base {  
    // ...
};
```

#### 使用场景：
- 设计不希望被扩展的类（如某些工具类、安全关键类）
- 防止类的层级结构被意外扩展
- 优化机会（编译器知道不会有派生类时可以做更多优化）



#### 2. 用于虚函数（禁止重写）

当 `final` 用于虚函数时，表示该虚函数不能在派生类中被进一步重写。

#### 语法：
```cpp
virtual void function() final;
```

#### 示例：
```cpp
class Base {
public:
    virtual void foo() final {
        // ...
    }
};

class Derived : public Base {
public:
    // 错误：不能重写 final 函数
    void foo() override {  
        // ...
    }
};
```

#### 使用场景：
- 设计不希望被修改的关键算法
- 固定某些接口行为的实现
- 防止派生类破坏基类的重要功能



#### 主要特点

1. **编译时检查**：违反 `final` 限制会导致编译错误
2. **语法位置**：
   - 对于类：放在类名后、基类列表前
   - 对于函数：放在函数声明后、`=0` 或函数体前
3. **与 `override` 的关系**：
   - `final` 和 `override` 可以一起使用
   - `override` 确保重写了基类虚函数
   - `final` 确保不会被进一步重写

```cpp
class Derived : public Base {
public:
    void foo() override final {  // 先override，再final
        // ...
    }
};
```



#### 实际应用价值

1. **设计意图明确化**：明确表示某些类或函数不应被修改
2. **防止意外继承**：避免类层次结构被不恰当地扩展
3. **性能优化**：编译器知道函数不会被重写时可能进行优化
4. **接口控制**：确保关键功能不被派生类破坏



#### 注意事项

1. `final` 不是成员访问控制（与 `public`/`protected`/`private` 不同）
2. 只能用于虚函数和可继承的类
3. 过度使用可能限制代码的灵活性
4. 在类定义中只能出现一次（在类名后）



#### 与 Java 的区别

C++ 的 `final` 与 Java 的 `final` 关键字有重要区别：

| 特性     | C++ `final`    | Java `final`     |
| -------- | -------------- | ---------------- |
| 用于类   | 禁止继承       | 无此功能         |
| 用于方法 | 禁止重写虚函数 | 禁止重写任何方法 |
| 用于变量 | 无此功能       | 使变量成为常量   |
| 用于参数 | 无此功能       | 禁止修改参数     |

`final` 关键字是现代 C++ 中增强类设计安全性的重要工具，合理使用可以使类层次结构更加健壮和可维护。



### 八. C++ 中 `using` 关键字的多种用法

`using` 是 C++ 中一个多功能关键字，在不同上下文中有不同的用途。以下是其主要用法：



#### 1. 类型别名（Type Aliasing）

C++11 引入的类型别名声明，比 `typedef` 更直观。

```cpp
using IntPtr = int*;          // 基本类型别名
using Callback = void(*)(int); // 函数指针别名

template<typename T>
using Vec = std::vector<T>;   // 模板别名
Vec<int> numbers;             // 等价于 std::vector<int>
```



#### 2. 命名空间使用声明

#### 引入整个命名空间
```cpp
using namespace std;  // 引入std命名空间所有符号
```

#### 引入特定符号
```cpp
using std::cout;      // 只引入cout
using std::endl;      // 只引入endl
```



#### 3. 继承中的使用声明（基类成员引入）

将基类成员引入派生类作用域，解决名称隐藏问题。

```cpp
class Base {
public:
    void func(int) {}
};

class Derived : public Base {
public:
    using Base::func;  // 引入Base的func
    void func(double) {}
};

Derived d;
d.func(1);  // 现在可以调用Base的func(int)
```



#### 4. 在类定义中引入类型成员

从基类引入类型定义到当前作用域。

```cpp
class Base {
public:
    using ValueType = int;
};

class Derived : public Base {
public:
    // 引入Base的ValueType
    using typename Base::ValueType;
    ValueType value;
};
```



#### 5. 移动构造/赋值函数的显式引入（C++11）

```cpp
class MyClass {
public:
    // 显式引入默认实现
    using Base::Base;           // 继承构造函数
    using Base::operator=;      // 继承赋值操作符
};
```



#### 6. 别名模板（Alias Templates）

C++11 新增功能，创建模板别名。

```cpp
template<typename T>
using MyAllocVector = std::vector<T, MyAllocator<T>>;

MyAllocVector<int> v;  // 使用自定义分配器的vector
```



#### 7. 配合 decltype 的类型推导

```cpp
using ResultType = decltype(a + b);
```



#### 8. 在模板元编程中使用

```cpp
template<typename T>
using RemoveConst = typename std::remove_const<T>::type;
```



#### 各用法对比表

| 用法分类     | 语法示例                              | 引入版本 | 主要用途         |
| ------------ | ------------------------------------- | -------- | ---------------- |
| 类型别名     | `using T = U;`                        | C++11    | 创建类型别名     |
| 命名空间引入 | `using namespace std;`                | C++98    | 引入命名空间     |
| 基类成员引入 | `using Base::member;`                 | C++98    | 解决名称隐藏     |
| 类型成员引入 | `using typename Base::Type;`          | C++98    | 引入嵌套类型     |
| 继承构造函数 | `using Base::Base;`                   | C++11    | 继承基类构造函数 |
| 别名模板     | `template<typename T> using V = ...;` | C++11    | 创建模板别名     |



#### 最佳实践建议

1. **优先使用 `using` 而非 `typedef`**：
   - 更清晰的语法，特别是对于函数指针和模板别名
   ```cpp
   // 更清晰的using语法
   using FuncPtr = void(*)(int, int);
   
   // 等价的typedef语法
   typedef void(*FuncPtr)(int, int);
   ```

2. **谨慎使用 `using namespace`**：
   - 在头文件中避免使用，防止命名空间污染
   - 在源文件中可以局部使用

3. **利用别名模板简化复杂类型**：
   ```cpp
   template<typename T>
   using Matrix = std::vector<std::vector<T>>;
   
   Matrix<double> mat;  // 清晰表达意图
   ```

4. **使用 `using` 解决多继承中的歧义**：
   ```cpp
   class A { public: void f() {} };
   class B { public: void f() {} };
   
   class C : public A, public B {
   public:
       using A::f;  // 明确使用A的f
   };
   ```

`using` 关键字在现代 C++ 中扮演着越来越重要的角色，特别是在模板编程和类型系统操作中，它提供了比传统 `typedef` 更强大和清晰的语法。



### 九. C++11 中的委托构造函数和继承构造函数

#### 委托构造函数 (Delegating Constructors)

**作用**：允许一个构造函数调用同类中的另一个构造函数，避免代码重复。

**特点**：
- 减少了构造函数中的冗余代码
- 提高了代码可维护性
- 必须在初始化列表中调用其他构造函数

**语法**：
```cpp
ClassName(参数列表1) : ClassName(参数列表2) { /* 其他初始化 */ }
```

**示例**：
```cpp
class MyClass {
    int a, b, c;
public:
    // 主构造函数
    MyClass(int x, int y, int z) : a(x), b(y), c(z) {}
    
    // 委托构造函数 - 调用主构造函数
    MyClass(int x) : MyClass(x, 0, 0) {}
    
    // 另一个委托构造函数
    MyClass() : MyClass(0, 0, 0) {}
};
```

**注意事项**：
1. 不能形成构造函数循环委托
2. 委托构造函数执行完成后才会执行函数体
3. 初始化列表中只能有委托调用，不能有其他成员初始化



#### 继承构造函数 (Inheriting Constructors)

**作用**：允许派生类直接继承基类的构造函数，而不必重新定义它们。

**特点**：
- 简化派生类构造函数的编写
- 适用于基类有多个构造函数的情况
- 使用 `using` 声明继承

**语法**：
```cpp
class Derived : public Base {
public:
    using Base::Base;  // 继承Base的所有构造函数
};
```

**示例**：
```cpp
class Base {
public:
    Base(int) {}
    Base(int, double) {}
    Base(int, double, std::string) {}
};

class Derived : public Base {
public:
    using Base::Base;  // 继承Base的三个构造函数
    
    // 可以添加派生类特有的构造函数
    Derived(const char*) : Base(0) {}
};
```

**注意事项**：
1. 继承的构造函数与基类构造函数有相同的访问权限
2. 如果派生类有新增成员变量，它们将被默认初始化
3. 可以与其他构造函数共存
4. 不能继承基类的默认/拷贝/移动构造函数（它们会被自动生成）



#### 两者对比

| 特性             | 委托构造函数             | 继承构造函数         |
| ---------------- | ------------------------ | -------------------- |
| **应用对象**     | 同类中的其他构造函数     | 基类的构造函数       |
| **语法**         | 在初始化列表中调用       | 使用 `using` 声明    |
| **主要目的**     | 减少同类构造函数代码重复 | 避免重写基类构造函数 |
| **对成员的影响** | 可以初始化所有成员       | 只能初始化继承的成员 |
| **版本引入**     | C++11                    | C++11                |

这两种特性都显著提高了C++构造函数的使用效率，减少了样板代码，使类设计更加清晰和简洁。



### 十. C++11 初始化列表的详细使用方法

C++11 引入了统一的初始化语法（Uniform Initialization），也称为初始化列表（Initializer List），它提供了一种更加一致和简洁的方式来初始化各种类型的对象。



#### 1. 基本语法

使用花括号 `{}` 进行初始化：

```cpp
// 基本类型
int x{5};        // 等同于 int x = 5;
double d{3.14};  // 等同于 double d = 3.14;

// 数组
int arr[]{1, 2, 3, 4, 5};

// 类对象
std::string str{"Hello"};

// STL容器
std::vector<int> vec{1, 2, 3, 4, 5};
```



#### 2. 类成员的初始化

#### 2.1 类内成员初始化

```cpp
class MyClass {
    int a{10};       // 直接初始化
    std::string b{"default"};
    double c = 3.14; // 也可以使用等号
};
```

#### 2.2 构造函数初始化列表

```cpp
class MyClass {
public:
    MyClass(int x, const std::string& y) 
        : a{x}, b{y}, c{0.0} {  // 使用花括号初始化
        // 构造函数体
    }
private:
    int a;
    std::string b;
    double c;
};
```



#### 3. 容器初始化

初始化列表特别适合STL容器的初始化：

```cpp
std::vector<int> v1{1, 2, 3};  // 包含3个元素:1,2,3
std::vector<int> v2(3, 1);     // 包含3个元素，每个都是1

std::map<std::string, int> m{
    {"apple", 1},
    {"banana", 2},
    {"orange", 3}
};
```



#### 4. 动态数组初始化

```cpp
int* p = new int[5]{1, 2, 3, 4, 5};
```



#### 5. 聚合类型初始化

对于没有用户自定义构造函数、没有私有/保护的非静态数据成员、没有基类和虚函数的类（聚合类型），可以直接使用初始化列表：

```cpp
struct Point {
    int x;
    int y;
    std::string name;
};

Point p{10, 20, "origin"};  // 直接初始化
```



#### 6. 窄化转换检查

初始化列表会检查窄化转换，防止精度丢失：

```cpp
int a{5.0};  // 错误: 从double到int的窄化转换
char c{999}; // 错误: 超出char范围
```



#### 7. 函数返回值初始化

```cpp
std::vector<int> getNumbers() {
    return {1, 2, 3, 4, 5};  // 返回初始化列表
}
```



#### 8. 注意事项

1. **与构造函数重载的交互**：
   - 如果类有 `initializer_list` 构造函数，优先匹配它
   - 否则匹配其他合适的构造函数

2. **auto 推导**：
   ```cpp
   auto x{5};    // C++11中推导为initializer_list<int>
   auto y = {5}; // 同上
   // C++17修正为直接推导为int
   ```

3. **空初始化列表**：
   ```cpp
   int x{};     // 值初始化为0
   std::string s{}; // 默认构造
   ```

4. **嵌套初始化**：
   ```cpp
   std::vector<std::vector<int>> matrix{
       {1, 2, 3},
       {4, 5, 6},
       {7, 8, 9}
   };
   ```



#### 9. 初始化列表的优势

1. 统一了各种初始化语法
2. 防止窄化转换
3. 支持容器直接初始化
4. 使初始化代码更加清晰直观
5. 支持初始化任意长度的对象列表



#### 10. 实际应用示例

```cpp
class Widget {
public:
    Widget(int x, double y) : x_{x}, y_{y} {}
    Widget(std::initializer_list<int> list) {
        // 处理初始化列表
    }
private:
    int x_;
    double y_;
};

Widget w1(5, 3.14);  // 调用普通构造函数
Widget w2{5, 10};     // 调用initializer_list构造函数
Widget w3{5, 3.14};   // 错误: 窄化转换
```

C++11的初始化列表提供了一种更现代、更安全的初始化方式，是现代C++编程中推荐使用的初始化方法。



### 十一. C++11 中的可调用对象

可调用对象（Callable Objects）是 C++11 中引入的一个重要概念，它统一了各种可以被调用的实体。在 C++11 中，主要有以下几种可调用对象：

#### 1. 函数指针（Function Pointers）

最传统的可调用对象形式。

```cpp
int add(int a, int b) { return a + b; }

// 函数指针
int (*funcPtr)(int, int) = &add;
int result = funcPtr(3, 4);  // 调用
```



#### 2. 函数对象（Functors/Function Objects）

重载了 `operator()` 的类对象。

```cpp
struct Adder {
    int operator()(int a, int b) const {
        return a + b;
    }
};

Adder adder;
int sum = adder(3, 4);  // 调用
```



#### 3. 成员函数指针（Member Function Pointers）

指向类成员函数的指针。

```cpp
class Math {
public:
    int add(int a, int b) { return a + b; }
};

Math math;
int (Math::*memFuncPtr)(int, int) = &Math::add;
int sum = (math.*memFuncPtr)(3, 4);  // 调用
```



#### 4. Lambda 表达式（C++11 新增）

匿名函数对象，可以捕获上下文变量。

```cpp
auto lambda = [](int a, int b) { return a + b; };
int sum = lambda(3, 4);

// 带捕获的lambda
int x = 10;
auto lambda2 = [x](int a) { return a + x; };
```



#### 5. std::function（C++11 新增）

通用的函数包装器，可以存储、复制和调用任何可调用对象。

```cpp
#include <functional>

std::function<int(int, int)> func;

// 可以绑定各种可调用对象
func = &add;            // 函数指针
func = Adder();         // 函数对象
func = [](int a, int b) { return a + b; };  // lambda

int sum = func(3, 4);   // 统一调用方式
```



#### 6. std::bind 绑定器（C++11 新增）

创建函数的部分应用或重新排列参数顺序。

```cpp
#include <functional>

void print(int a, double b, const std::string& c) {
    std::cout << a << ", " << b << ", " << c << std::endl;
}

// 绑定参数
auto boundFunc = std::bind(print, 10, std::placeholders::_1, "Hello");
boundFunc(3.14);  // 输出: 10, 3.14, Hello
```



#### 7. 可调用对象的类型擦除

`std::function` 实现了类型擦除，可以统一处理各种可调用对象：

```cpp
void process(std::function<int(int, int)> func) {
    std::cout << func(3, 4) << std::endl;
}

process(&add);      // 函数指针
process(Adder());   // 函数对象
process([](int a, int b) { return a + b; });  // lambda
```



#### 8. 可调用对象的特性总结

| 类型          | 语法示例                   | 特点             | 适用场景       |
| ------------- | -------------------------- | ---------------- | -------------- |
| 函数指针      | `int (*)(int, int)`        | 最原始，类型严格 | C兼容代码      |
| 函数对象      | 重载`operator()`           | 可携带状态       | 需要状态的算法 |
| Lambda        | `[](args){body}`           | 简洁，可捕获     | 局部简单逻辑   |
| std::function | `std::function<ret(args)>` | 类型擦除，通用   | 回调函数存储   |
| std::bind     | `std::bind(func, args)`    | 参数绑定/重排    | 适配接口       |



#### 9. 实际应用示例

```cpp
#include <iostream>
#include <functional>
#include <vector>

// 使用std::function作为回调函数类型
void registerCallback(std::function<void(int)> callback) {
    callback(42);  // 调用回调
}

int main() {
    // 1. 使用lambda作为回调
    registerCallback([](int value) {
        std::cout << "Lambda callback: " << value << std::endl;
    });

    // 2. 存储多种可调用对象
    std::vector<std::function<int(int, int)>> operations;
    operations.push_back([](int a, int b) { return a + b; });
    operations.push_back([](int a, int b) { return a * b; });
    
    for (auto& op : operations) {
        std::cout << op(3, 4) << std::endl;
    }

    // 3. 使用bind绑定参数
    auto greet = [](const std::string& name, int times) {
        for (int i = 0; i < times; ++i) {
            std::cout << "Hello, " << name << "!" << std::endl;
        }
    };
    
    auto sayHello = std::bind(greet, "World", 3);
    sayHello();  // 输出3次Hello, World!
}
```

C++11 的可调用对象机制大大增强了语言的表达能力和灵活性，为函数式编程风格和回调机制提供了强有力的支持。