## C++ 11新特性



#### 一. 原始字面量(Raw String Literals)：

它允许在字符串中直接包含换行符，反斜杠等特殊字符，而不需要进行转移。



**基本语法：**

```cpp
// 这里delimiter两边必须一样，相当于注释的作用
R"delimiter(raw_characters)delimiter"
```

1. R 表示这是一个原始字符串

2. delimiter 是可选的定界符，可以是空（此时语法为 R"(...)"）

3. raw_characters 是字符串的实际内容

**主要特点:**

1. 无需转义特殊字符：在原始字符串中，反斜杠\、引号"等字符都按字面意义处理

   ```cpp
   std::string path = R"(C:\Program Files\MyApp)";  // 不需要转义反斜杠
   ```

   

2. 保留换行和缩进：字符串中的换行符和缩进都会被保留

   ```cpp
   std::string text = R"(
       Hello,
       This is a multi-line
       raw string literal.
   )";
   ```

   

3. 可自定义定界符：当字符串本身包含)"时，可以使用自定义定界符来避免冲突

```cpp
std::string regex = R"delimiter((\w+)=("([^"]*)")delimiter";
```



#### 二. `nullptr`

用于表示空指针常量，它解决了传统NULL宏带来的一些问题。

![image-20250413202229871](C:\Users\刘世杰\AppData\Roaming\Typora\typora-user-images\image-20250413202229871.png)

**为什么需要`nullptr`？**

在C++98/03中，通常使用NULL宏表示空指针，但NULL通常定义为0或(void*)0，这会导致一些问题：

1. **类型安全问题**：NULL实际上是整数0，可以隐式转换为任何指针类型，也可能与整数类型混淆

   ```cpp
   void func(int);
   void func(char*);
   
   func(NULL);  // 调用哪个？可能调用func(int)而不是预期的func(char*)
   ```

   

2. **模板推导问题**：在模板中，NULL的类型推导可能不符合预期



**`nullptr`的特性：**

1. **明确的指针类型**：`nullptr`的类型是std::nullptr_t，可以隐式转换为任何指针类型

```cpp
int* ptr = nullptr;
char* str = nullptr;
```

2. __不会与整数类型混淆：`__nullptr`不能转换为整数类型

```cpp
int i = nullptr;  // 错误
```

3. __解决函数重载问题：__

```cpp
void func(int);
void func(char*);

func(nullptr);  // 明确调用func(char*)
```

4. __模板友好：__在模板编程中能正确推导指针类型

```cpp
template<typename T>
void f(T* ptr);

f(nullptr);  // T被推导为std::nullptr_t
```

__使用实例：__

```cpp
// 函数重载示例
void foo(int) { std::cout << "foo(int)\n"; }
void foo(char*) { std::cout << "foo(char*)\n"; }

foo(0);         // 调用foo(int)
foo(nullptr);   // 调用foo(char*)

// 指针初始化
int* p1 = nullptr;
if (p1 == nullptr) { /* ... */ }

// 作为函数参数
void bar(std::string* s = nullptr) {
    if (s != nullptr) { /* ... */ }
}
```



#### 三.` constexpr`修饰常量表达式

用于指定变量或函数可以在编译时求值，从而支持编译期计算和优化。



__基本概念：__

__`constexpr`__表示"常量表达式"(constant expression)，主要有两种用途：

1. 声明常量表达式变量

2. 声明常量表达式函数



__`constexpr`变量:__
`constexpr`变量必须在编译时就确定其值：



__与`cons`t的区别：__

1. `const`只表示"不可修改"，但不一定是编译期常量

2. `constexpr`一定是编译期常量

```cpp
constexpr int size = 10;              // 编译时常量
constexpr double pi = 3.1415926535;   // 编译时常量
```



__`constexpr`函数:__

`constexpr`函数可以在编译时被求值，前提是传入的参数也是编译时常量：



__`constexpr`函数限制(C++11)：__

1. 函数体必须只包含单个return语句(不能有循环、分支等)

2. 只能调用其他`constexpr`函数

3. 只能使用全局变量或字面量类型的参数

```cpp
constexpr int factorial(int n) {
    return n <= 1 ? 1 : n * factorial(n - 1);
}

int main() {
    constexpr int fact5 = factorial(5);  // 编译时计算，结果为120
    int n = 5;
    int fact_n = factorial(n);          // 运行时计算
}
```



__主要用途:__

1. 编译期计算：

   ```cpp
   constexpr int array_size = 10;
   int arr[array_size];  // 数组大小在编译时确定
   ```

2. 替代宏常量：

   ```cpp
   constexpr double gravity = 9.8;  // 比#define更安全
   ```

3. 模板元编程：

   ```cpp
   template<int N>
   struct Factorial {
       static constexpr int value = N * Factorial<N-1>::value;
   };
   ```

4. 与静态断言配合：

   ```cpp
   static_assert(factorial(5) == 120, "Factorial error");
   ```

   

__C++11 vs C++14的`constexpr`:__
在C++14中，`constexpr`函数的限制大大放宽：

1. 允许局部变量

2. 允许循环和分支语句

3. 允许修改生命周期在函数内的对象



__注意事项:__

1. `constexpr`变量必须立即初始化

2. `constexpr`函数在编译期调用时才在编译期求值，否则在运行时求值

3. 不是所有类型都可以是`constexpr`，必须是字面类型(literal type)



#### 三. auto

用于自动类型推导，它可以让编译器根据初始化表达式自动推导变量的类型，从而简化代码编写。

![image-20250413211924051](C:\Users\刘世杰\AppData\Roaming\Typora\typora-user-images\image-20250413211924051.png)

__基本用法:__

1. 变量声明:

   ```cpp
   auto x = 5;          // x 被推导为 int
   auto y = 3.14;       // y 被推导为 double
   auto str = "hello";  // str 被推导为 const char*
   ```

2. 复杂类型简化:

   ```cpp
   std::vector<std::string> names = {"Alice", "Bob", "Charlie"};
   
   // 传统写法
   std::vector<std::string>::iterator it = names.begin();
   
   // 使用 auto 简化
   auto it = names.begin();  // 自动推导为 std::vector<std::string>::iterator
   ```

   

__主要优势:__

1. 减少冗长类型名：特别是模板类型和嵌套类型

   ```cpp
   std::unordered_map<std::string, std::vector<int>> complexMap;
   
   // 不使用 auto
   std::pair<const std::string, std::vector<int>>& entry = *complexMap.begin();
   
   // 使用 auto
   auto& entry = *complexMap.begin();
   ```

   

2. 泛型编程更简洁：

   ```cpp
   template <typename T, typename U>
   auto add(T t, U u) -> decltype(t + u) {
       return t + u;
   }
   ```

   

3. 支持lambda表达式存储：

   ```cpp
   auto lambda = [](int x) { return x * 2; };
   ```

__使用场景:__
1. 迭代器简化

   ```cpp
   std::vector<int> vec = {1, 2, 3};
   for (auto it = vec.begin(); it != vec.end(); ++it) {
       std::cout << *it << std::endl;
   }
   ```

   

2. 范围for循环

   ```cpp
   for (auto& num : vec) {  // 自动推导元素类型
       num *= 2;
   }
   ```

   

3. 函数返回类型推导 (C++14扩展)

   ```cpp
   auto multiply(double a, double b) {
       return a * b;  // 返回类型自动推导为 double
   }
   ```

__注意事项:__

1. 必须初始化：auto 变量必须初始化

2. 引用和`const`限定：

3. 数组退化：

4. 类型精确控制：

   （1）使用 `auto* `确保指针类型

   （2）使用 `const auto` 确保常量性

​	__当变量不是指针或者引用类型时，推导的结果中不会保留`const`，volatile关键字__

​	__当变量是指针或者引用类型时，推导的结果中会保留`const`，volatile关键字__

5. 一些限制：

   （1）不能作为函数参数使用

   （2）不能用于类的非静态成员变量的初始化

   （3）不能使用auto关键字定义数组 (auto t = array,这里t被推导成数组指针)

   （4）无法使用auto推导出模板参数



#### 四. decltype

`decltype` 是 C++11 引入的类型推导关键字，用于**查询表达式的类型**。它可以在编译时推导出表达式的确切类型，包括保留引用和 `const` 限定符。

#### 基本语法:

```cpp
decltype(expression) variable;
```

#### 推断规则：

规则 1：简单变量名，保留所有类型信息（包括引用和 cv 限定符）

规则 2：非变量名表达式
	编译器会检查表达式的结果：

​	1. 如果表达式是左值 → T&

​	2. 如果表达式是将亡值（xvalue）→ T&&

​	3. 如果表达式是纯右值（prvalue）→ T

#### 主要特性:

1. **精确类型推导**：完全保留表达式的类型信息，包括引用和 `const` 限定
   
   ```cpp
   int i = 42;
   const int& r = i;
   decltype(r) x = i;  // x 的类型是 const int&
   ```
   
2. **与 `auto` 的区别**：
   - `auto` 忽略顶层 `const` 和引用（除非显式指定）
   - `decltype` 完全保留表达式的类型 （如果某个函数f返回一个右值，那么使用decltype(f)进行推导时，会将const忽略掉）

   ```cpp
   const int ci = 0;
   auto a = ci;        // a 是 int (忽略顶层const)
   decltype(ci) b = 0; // b 是 const int
   ```

#### 使用场景

1. 函数返回类型推导

```cpp
template <typename T, typename U>
auto add(T t, U u) -> decltype(t + u) {
    return t + u;
}
```

2. 元编程和类型萃取

```cpp
template <typename T>
void print_type() {
    std::cout << typeid(decltype(T())).name() << std::endl;
}
```

3. 复杂表达式类型捕获

```cpp
std::vector<int> vec;
decltype(vec.size()) size = vec.size();  // 正确获取size_type类型
```

4. Lambda表达式类型捕获

```cpp
auto lambda = [](int x) { return x * 1.5; };
decltype(lambda) copy = lambda;  // 精确复制lambda类型
```

特殊规则

1. **变量名**：给出变量的声明类型（包括引用）
   ```cpp
   int i = 0;
   decltype(i) x;  // x 是 int
   ```

2. **表达式**：给出表达式结果的类型
   ```cpp
   int i = 0;
   decltype((i)) y = i;  // y 是 int& (因为(i)是左值表达式)
   ```

3. **函数调用**：给出函数的返回类型
   ```cpp
   decltype(std::declval<std::string>().size()) len;  // len是size_type
   ```

#### 与 `auto` 的对比

| 特性        | `decltype`   | `auto`               |
| ----------- | ------------ | -------------------- |
| 引用保留    | 总是保留     | 需要显式指定 (auto&) |
| `const`保留 | 总是保留     | 顶层`const`被忽略    |
| 数组类型    | 保留数组类型 | 退化为指针           |
| 表达式求值  | 不实际求值   | 需要初始化表达式     |
| 主要用途    | 类型查询     | 变量类型推导         |

#### 实际应用示例

1. 通用函数返回类型

```cpp
template <typename Container>
auto getFirst(Container& c) -> decltype(c[0]) {
    return c[0];
}
```

2. 类型萃取

```cpp
template <typename T>
using RemoveReference = typename std::remove_reference<decltype(std::declval<T>())>::type;
```

3. SFINAE 应用

```cpp
template <typename T>
auto check_has_size(T& t) -> decltype(t.size(), std::true_type{});
```

注意事项

1. `decltype` 不计算表达式的值，只分析类型
2. 对于变量名和表达式有不同的推导规则
3. 在模板元编程中特别有用
4. C++14 引入了 `decltype(auto)` 进一步简化某些用法

`decltype` 为 C++ 提供了强大的编译时类型查询能力，是模板编程和泛型编程中的重要工具，特别是在需要精确控制类型信息的场景下非常有用。



#### 五. volatile

`volatile` 是 C++ 中的一个类型修饰符，用于告诉编译器该变量可能会在程序控制之外被意外修改，从而防止编译器对该变量的访问进行优化。

#### 基本作用:

`volatile` 的主要作用是：
1. **禁止编译器优化**：防止编译器对 volatile 变量的读写操作进行优化（如删除"冗余"读取或缓存值）

2. **保证访问顺序**：确保对 volatile 变量的操作按照代码顺序执行

3. **用于特殊内存**：标记那些可能被硬件、中断服务程序或多线程修改的内存

   

#### 基本语法:

```cpp
volatile int counter;          // volatile变量
volatile int* pToVolatile;     // 指向volatile数据的指针
int* volatile volatilePtr;     // volatile指针(指针本身是volatile)
volatile int* volatile pBoth; // 指针和指向的数据都是volatile
```



#### 典型使用场景:

1. 硬件寄存器访问

```cpp
// 假设0x1234是一个硬件寄存器地址
volatile uint32_t* const hardwareReg = reinterpret_cast<uint32_t*>(0x1234);

// 每次读取都会实际访问硬件寄存器
uint32_t value = *hardwareReg;
```

2. 多线程共享变量 (注意：volatile 不能替代原子操作或互斥锁)

```cpp
volatile bool flag = false;

// 线程1
void thread1() {
    while(!flag) {} // 等待flag变为true
    // 执行操作
}

// 线程2
void thread2() {
    // 做一些工作...
    flag = true; // 通知线程1
}
```

3. 信号处理程序中的变量

```cpp
volatile sig_atomic_t signalReceived = 0;

void signalHandler(int) {
    signalReceived = 1;
}

int main() {
    signal(SIGINT, signalHandler);
    while(!signalReceived) {
        // 正常处理
    }
    // 收到信号后的处理
}
```



#### 与 `const` 的结合使用

`volatile` 可以与 `const` 一起使用，表示变量本身不应该被程序修改，但可能被外部因素修改：

```cpp
const volatile uint32_t* readOnlyReg = ...;
// 程序不能修改 *readOnlyReg，但它可能被硬件改变
```



#### 重要注意事项

1. **不是线程安全保证**：
   - `volatile` **不**提供原子性保证
   - `volatile` **不**解决内存可见性问题
   - 在多线程编程中，应该使用 `std::atomic` 或互斥锁

2. **与优化相关**：
   ```cpp
   int normalVar = 0;
   volatile int volatileVar = 0;
   
   normalVar = 1;    // 编译器可能优化掉这条语句如果没有后续使用
   volatileVar = 1;  // 一定会执行，不会被优化
   ```

3. **访问保证**：
   - 每次访问 volatile 变量都会从内存中读取或写入
   - 操作不会被重新排序（相对于其他 volatile 操作）



#### volatile 与 constexpr

`volatile` 和 `constexpr` 是互斥的，因为：
- `constexpr` 表示编译时常量
- `volatile` 表示运行时可能被意外修改

```cpp
// 错误：不能同时使用
constexpr volatile int x = 10; 
```



#### 现代C++中的替代方案

1. 对于硬件访问：考虑使用特定于平台的 memory-mapped I/O 库
2. 对于多线程：使用 `<atomic>` 头文件中的 `std::atomic`
3. 对于信号处理：仍然需要 `volatile sig_atomic_t`



#### 总结

`volatile` 的正确使用场景：
- 内存映射的硬件寄存器
- 被中断服务程序修改的变量
- 被不同线程访问且平台保证原子性的基本类型变量
- 信号处理程序中使用的全局变量

在大多数常规编程中，特别是多线程编程，应该优先考虑使用 `std::atomic` 而不是 `volatile`。



### 六. 返回值类型后置语法

返回值类型后置（Trailing Return Type）是 C++11 引入的一种函数声明语法，它允许将函数的返回类型放在参数列表之后，使用 `->` 符号引导。



#### 基本语法

```cpp
auto 函数名(参数列表) -> 返回类型 {
    // 函数体
}
```



#### 主要用途

1. 配合 `decltype` 使用（解决模板编程中类型依赖问题）

```cpp
template <typename T, typename U>
auto add(T x, U y) -> decltype(x + y) {
    return x + y;
}
```

2. 简化复杂返回类型的声明

```cpp
// 传统方式
std::vector<int>::iterator getIter(std::vector<int>& v);

// 使用后置返回类型
auto getIter(std::vector<int>& v) -> std::vector<int>::iterator;
```

3. Lambda 表达式的返回类型指定

```cpp
auto lambda = [](int x) -> double {
    return x * 1.5;
};
```



#### 优势特点

1. **解决类型依赖问题**：当返回类型依赖于参数类型时特别有用
   
   ```cpp
   template <typename Container>
   auto begin(Container& c) -> decltype(c.begin()) {
       return c.begin();
   }
   ```
   
2. **提高可读性**：对于复杂返回类型更清晰
   ```cpp
   auto (*getFunc())(int, int) -> int;  // 传统方式难以阅读
   auto getFunc() -> int(*)(int, int);  // 后置方式更清晰
   ```

3. **统一语法**：与 lambda 表达式语法保持一致



#### 实际应用示例

1. 模板函数中的类型推导

```cpp
template <typename T>
auto process(T data) -> typename T::value_type {
    return *data.begin();
}
```

2. 返回数组引用

```cpp
auto getArray() -> int(&)[10] {
    static int arr[10];
    return arr;
}
```

3. 复杂函数指针返回

```cpp
auto getCallback() -> void(*)(int, const std::string&) {
    return [](int, const std::string&){ /*...*/ };
}
```



#### 注意事项

1. 必须使用 `auto` 作为前导关键字
2. 在类定义中同样适用
   ```cpp
   class MyClass {
   public:
       auto method() -> int;
   };
   ```
3. C++14 开始可以省略后置返回类型（使用 `auto` 自动推导），但在需要明确类型或类型依赖参数时仍需使用



#### 与 C++14 自动返回类型推导的区别

| 特性       | 返回值类型后置        | C++14 自动返回类型推导         |
| ---------- | --------------------- | ------------------------------ |
| 语法       | `auto func() -> type` | `auto func()`                  |
| 类型明确性 | 显式指定              | 由编译器推导                   |
| 模板依赖   | 必须使用              | 不能用于依赖模板参数的返回类型 |
| 可读性     | 复杂类型更清晰        | 简单类型更简洁                 |

返回值类型后置语法是现代 C++ 中非常重要的特性，特别是在模板编程和泛型编程中，它解决了返回类型依赖参数类型时的声明问题，使代码更加灵活和可维护。



### 七. `final`

`final` 是 C++11 引入的一个重要关键字，用于限制类或虚函数的进一步继承或重写。它提供了两种主要用途：



#### 1. 用于类（禁止继承）

当 `final` 用于类定义时，表示该类不能被继承。

#### 语法：
```cpp
class ClassName final {
    // 类成员
};
```

#### 示例：
```cpp
class Base final {
    // ...
};

// 错误：不能继承 final 类
class Derived : public Base {  
    // ...
};
```

#### 使用场景：
- 设计不希望被扩展的类（如某些工具类、安全关键类）
- 防止类的层级结构被意外扩展
- 优化机会（编译器知道不会有派生类时可以做更多优化）



#### 2. 用于虚函数（禁止重写）

当 `final` 用于虚函数时，表示该虚函数不能在派生类中被进一步重写。

#### 语法：
```cpp
virtual void function() final;
```

#### 示例：
```cpp
class Base {
public:
    virtual void foo() final {
        // ...
    }
};

class Derived : public Base {
public:
    // 错误：不能重写 final 函数
    void foo() override {  
        // ...
    }
};
```

#### 使用场景：
- 设计不希望被修改的关键算法
- 固定某些接口行为的实现
- 防止派生类破坏基类的重要功能



#### 主要特点

1. **编译时检查**：违反 `final` 限制会导致编译错误
2. **语法位置**：
   - 对于类：放在类名后、基类列表前
   - 对于函数：放在函数声明后、`=0` 或函数体前
3. **与 `override` 的关系**：
   - `final` 和 `override` 可以一起使用
   - `override` 确保重写了基类虚函数
   - `final` 确保不会被进一步重写

```cpp
class Derived : public Base {
public:
    void foo() override final {  // 先override，再final
        // ...
    }
};
```



#### 实际应用价值

1. **设计意图明确化**：明确表示某些类或函数不应被修改
2. **防止意外继承**：避免类层次结构被不恰当地扩展
3. **性能优化**：编译器知道函数不会被重写时可能进行优化
4. **接口控制**：确保关键功能不被派生类破坏



#### 注意事项

1. `final` 不是成员访问控制（与 `public`/`protected`/`private` 不同）
2. 只能用于虚函数和可继承的类
3. 过度使用可能限制代码的灵活性
4. 在类定义中只能出现一次（在类名后）



#### 与 Java 的区别

C++ 的 `final` 与 Java 的 `final` 关键字有重要区别：

| 特性     | C++ `final`    | Java `final`     |
| -------- | -------------- | ---------------- |
| 用于类   | 禁止继承       | 无此功能         |
| 用于方法 | 禁止重写虚函数 | 禁止重写任何方法 |
| 用于变量 | 无此功能       | 使变量成为常量   |
| 用于参数 | 无此功能       | 禁止修改参数     |

`final` 关键字是现代 C++ 中增强类设计安全性的重要工具，合理使用可以使类层次结构更加健壮和可维护。



### 八. C++ 中 `using` 关键字的多种用法

`using` 是 C++ 中一个多功能关键字，在不同上下文中有不同的用途。以下是其主要用法：



#### 1. 类型别名（Type Aliasing）

C++11 引入的类型别名声明，比 `typedef` 更直观。

```cpp
using IntPtr = int*;          // 基本类型别名
using Callback = void(*)(int); // 函数指针别名

template<typename T>
using Vec = std::vector<T>;   // 模板别名
Vec<int> numbers;             // 等价于 std::vector<int>
```



#### 2. 命名空间使用声明

#### 引入整个命名空间
```cpp
using namespace std;  // 引入std命名空间所有符号
```

#### 引入特定符号
```cpp
using std::cout;      // 只引入cout
using std::endl;      // 只引入endl
```



#### 3. 继承中的使用声明（基类成员引入）

将基类成员引入派生类作用域，解决名称隐藏问题。

```cpp
class Base {
public:
    void func(int) {}
};

class Derived : public Base {
public:
    using Base::func;  // 引入Base的func
    void func(double) {}
};

Derived d;
d.func(1);  // 现在可以调用Base的func(int)
```



#### 4. 在类定义中引入类型成员

从基类引入类型定义到当前作用域。

```cpp
class Base {
public:
    using ValueType = int;
};

class Derived : public Base {
public:
    // 引入Base的ValueType
    using typename Base::ValueType;
    ValueType value;
};
```



#### 5. 移动构造/赋值函数的显式引入（C++11）

```cpp
class MyClass {
public:
    // 显式引入默认实现
    using Base::Base;           // 继承构造函数
    using Base::operator=;      // 继承赋值操作符
};
```



#### 6. 别名模板（Alias Templates）

C++11 新增功能，创建模板别名。

```cpp
template<typename T>
using MyAllocVector = std::vector<T, MyAllocator<T>>;

MyAllocVector<int> v;  // 使用自定义分配器的vector
```



#### 7. 配合 decltype 的类型推导

```cpp
using ResultType = decltype(a + b);
```



#### 8. 在模板元编程中使用

```cpp
template<typename T>
using RemoveConst = typename std::remove_const<T>::type;
```



#### 各用法对比表

| 用法分类     | 语法示例                              | 引入版本 | 主要用途         |
| ------------ | ------------------------------------- | -------- | ---------------- |
| 类型别名     | `using T = U;`                        | C++11    | 创建类型别名     |
| 命名空间引入 | `using namespace std;`                | C++98    | 引入命名空间     |
| 基类成员引入 | `using Base::member;`                 | C++98    | 解决名称隐藏     |
| 类型成员引入 | `using typename Base::Type;`          | C++98    | 引入嵌套类型     |
| 继承构造函数 | `using Base::Base;`                   | C++11    | 继承基类构造函数 |
| 别名模板     | `template<typename T> using V = ...;` | C++11    | 创建模板别名     |



#### 最佳实践建议

1. **优先使用 `using` 而非 `typedef`**：
   - 更清晰的语法，特别是对于函数指针和模板别名
   ```cpp
   // 更清晰的using语法
   using FuncPtr = void(*)(int, int);
   
   // 等价的typedef语法
   typedef void(*FuncPtr)(int, int);
   ```

2. **谨慎使用 `using namespace`**：
   - 在头文件中避免使用，防止命名空间污染
   - 在源文件中可以局部使用

3. **利用别名模板简化复杂类型**：
   ```cpp
   template<typename T>
   using Matrix = std::vector<std::vector<T>>;
   
   Matrix<double> mat;  // 清晰表达意图
   ```

4. **使用 `using` 解决多继承中的歧义**：
   ```cpp
   class A { public: void f() {} };
   class B { public: void f() {} };
   
   class C : public A, public B {
   public:
       using A::f;  // 明确使用A的f
   };
   ```

`using` 关键字在现代 C++ 中扮演着越来越重要的角色，特别是在模板编程和类型系统操作中，它提供了比传统 `typedef` 更强大和清晰的语法。



### 九. C++11 中的委托构造函数和继承构造函数

#### 委托构造函数 (Delegating Constructors)

**作用**：允许一个构造函数调用同类中的另一个构造函数，避免代码重复。

**特点**：
- 减少了构造函数中的冗余代码
- 提高了代码可维护性
- 必须在初始化列表中调用其他构造函数

**语法**：
```cpp
ClassName(参数列表1) : ClassName(参数列表2) { /* 其他初始化 */ }
```

**示例**：
```cpp
class MyClass {
    int a, b, c;
public:
    // 主构造函数
    MyClass(int x, int y, int z) : a(x), b(y), c(z) {}
    
    // 委托构造函数 - 调用主构造函数
    MyClass(int x) : MyClass(x, 0, 0) {}
    
    // 另一个委托构造函数
    MyClass() : MyClass(0, 0, 0) {}
};
```

**注意事项**：
1. 不能形成构造函数循环委托
2. 委托构造函数执行完成后才会执行函数体
3. 初始化列表中只能有委托调用，不能有其他成员初始化



#### 继承构造函数 (Inheriting Constructors)

**作用**：允许派生类直接继承基类的构造函数，而不必重新定义它们。

**特点**：
- 简化派生类构造函数的编写
- 适用于基类有多个构造函数的情况
- 使用 `using` 声明继承

**语法**：
```cpp
class Derived : public Base {
public:
    using Base::Base;  // 继承Base的所有构造函数
};
```

**示例**：
```cpp
class Base {
public:
    Base(int) {}
    Base(int, double) {}
    Base(int, double, std::string) {}
};

class Derived : public Base {
public:
    using Base::Base;  // 继承Base的三个构造函数
    
    // 可以添加派生类特有的构造函数
    Derived(const char*) : Base(0) {}
};
```

**注意事项**：
1. 继承的构造函数与基类构造函数有相同的访问权限
2. 如果派生类有新增成员变量，它们将被默认初始化
3. 可以与其他构造函数共存
4. 不能继承基类的默认/拷贝/移动构造函数（它们会被自动生成）



#### 两者对比

| 特性             | 委托构造函数             | 继承构造函数         |
| ---------------- | ------------------------ | -------------------- |
| **应用对象**     | 同类中的其他构造函数     | 基类的构造函数       |
| **语法**         | 在初始化列表中调用       | 使用 `using` 声明    |
| **主要目的**     | 减少同类构造函数代码重复 | 避免重写基类构造函数 |
| **对成员的影响** | 可以初始化所有成员       | 只能初始化继承的成员 |
| **版本引入**     | C++11                    | C++11                |

这两种特性都显著提高了C++构造函数的使用效率，减少了样板代码，使类设计更加清晰和简洁。



### 十. C++11 初始化列表的详细使用方法

C++11 引入了统一的初始化语法（Uniform Initialization），也称为初始化列表（Initializer List），它提供了一种更加一致和简洁的方式来初始化各种类型的对象。



#### 1. 基本语法

使用花括号 `{}` 进行初始化：

```cpp
// 基本类型
int x{5};        // 等同于 int x = 5;
double d{3.14};  // 等同于 double d = 3.14;

// 数组
int arr[]{1, 2, 3, 4, 5};

// 类对象
std::string str{"Hello"};

// STL容器
std::vector<int> vec{1, 2, 3, 4, 5};
```



#### 2. 类成员的初始化

#### 2.1 类内成员初始化

```cpp
class MyClass {
    int a{10};       // 直接初始化
    std::string b{"default"};
    double c = 3.14; // 也可以使用等号
};
```

#### 2.2 构造函数初始化列表

```cpp
class MyClass {
public:
    MyClass(int x, const std::string& y) 
        : a{x}, b{y}, c{0.0} {  // 使用花括号初始化
        // 构造函数体
    }
private:
    int a;
    std::string b;
    double c;
};
```



#### 3. 容器初始化

初始化列表特别适合STL容器的初始化：

```cpp
std::vector<int> v1{1, 2, 3};  // 包含3个元素:1,2,3
std::vector<int> v2(3, 1);     // 包含3个元素，每个都是1

std::map<std::string, int> m{
    {"apple", 1},
    {"banana", 2},
    {"orange", 3}
};
```



#### 4. 动态数组初始化

```cpp
int* p = new int[5]{1, 2, 3, 4, 5};
```



#### 5. 聚合类型初始化

对于没有用户自定义构造函数、没有私有/保护的非静态数据成员、没有基类和虚函数的类（聚合类型），可以直接使用初始化列表：

```cpp
struct Point {
    int x;
    int y;
    std::string name;
};

Point p{10, 20, "origin"};  // 直接初始化
```



#### 6. 窄化转换检查

初始化列表会检查窄化转换，防止精度丢失：

```cpp
int a{5.0};  // 错误: 从double到int的窄化转换
char c{999}; // 错误: 超出char范围
```



#### 7. 函数返回值初始化

```cpp
std::vector<int> getNumbers() {
    return {1, 2, 3, 4, 5};  // 返回初始化列表
}
```



#### 8. 注意事项

1. **与构造函数重载的交互**：
   - 如果类有 `initializer_list` 构造函数，优先匹配它
   - 否则匹配其他合适的构造函数

2. **auto 推导**：
   ```cpp
   auto x{5};    // C++11中推导为initializer_list<int>
   auto y = {5}; // 同上
   // C++17修正为直接推导为int
   ```

3. **空初始化列表**：
   ```cpp
   int x{};     // 值初始化为0
   std::string s{}; // 默认构造
   ```

4. **嵌套初始化**：
   ```cpp
   std::vector<std::vector<int>> matrix{
       {1, 2, 3},
       {4, 5, 6},
       {7, 8, 9}
   };
   ```



#### 9. 初始化列表的优势

1. 统一了各种初始化语法
2. 防止窄化转换
3. 支持容器直接初始化
4. 使初始化代码更加清晰直观
5. 支持初始化任意长度的对象列表



#### 10. 实际应用示例

```cpp
class Widget {
public:
    Widget(int x, double y) : x_{x}, y_{y} {}
    Widget(std::initializer_list<int> list) {
        // 处理初始化列表
    }
private:
    int x_;
    double y_;
};

Widget w1(5, 3.14);  // 调用普通构造函数
Widget w2{5, 10};     // 调用initializer_list构造函数
Widget w3{5, 3.14};   // 错误: 窄化转换
```

C++11的初始化列表提供了一种更现代、更安全的初始化方式，是现代C++编程中推荐使用的初始化方法。



### 十一. C++11 中的可调用对象

可调用对象（Callable Objects）是 C++11 中引入的一个重要概念，它统一了各种可以被调用的实体。在 C++11 中，主要有以下几种可调用对象：

#### 1. 函数指针（Function Pointers）

最传统的可调用对象形式。

```cpp
int add(int a, int b) { return a + b; }

// 函数指针
int (*funcPtr)(int, int) = &add;
int result = funcPtr(3, 4);  // 调用
```



#### 2. 函数对象（Functors/Function Objects）

重载了 `operator()` 的类对象。

```cpp
struct Adder {
    int operator()(int a, int b) const {
        return a + b;
    }
};

Adder adder;
int sum = adder(3, 4);  // 调用
```



#### 3. 成员函数指针（Member Function Pointers）

指向类成员函数的指针。

```cpp
class Math {
public:
    int add(int a, int b) { return a + b; }
};

Math math;
int (Math::*memFuncPtr)(int, int) = &Math::add;
int sum = (math.*memFuncPtr)(3, 4);  // 调用
```



#### 4. Lambda 表达式（C++11 新增）

匿名函数对象，可以捕获上下文变量。

```cpp
auto lambda = [](int a, int b) { return a + b; };
int sum = lambda(3, 4);

// 带捕获的lambda
int x = 10;
auto lambda2 = [x](int a) { return a + x; };
```



#### 5. std::function（C++11 新增）

通用的函数包装器，可以存储、复制和调用任何可调用对象。

```cpp
#include <functional>

std::function<int(int, int)> func;

// 可以绑定各种可调用对象
func = &add;            // 函数指针
func = Adder();         // 函数对象
func = [](int a, int b) { return a + b; };  // lambda

int sum = func(3, 4);   // 统一调用方式
```



#### 6. std::bind 绑定器（C++11 新增）

创建函数的部分应用或重新排列参数顺序。

```cpp
#include <functional>

void print(int a, double b, const std::string& c) {
    std::cout << a << ", " << b << ", " << c << std::endl;
}

// 绑定参数
auto boundFunc = std::bind(print, 10, std::placeholders::_1, "Hello");
boundFunc(3.14);  // 输出: 10, 3.14, Hello
```



#### 7. 可调用对象的类型擦除

`std::function` 实现了类型擦除，可以统一处理各种可调用对象：

```cpp
void process(std::function<int(int, int)> func) {
    std::cout << func(3, 4) << std::endl;
}

process(&add);      // 函数指针
process(Adder());   // 函数对象
process([](int a, int b) { return a + b; });  // lambda
```



#### 8. 可调用对象的特性总结

| 类型          | 语法示例                   | 特点             | 适用场景       |
| ------------- | -------------------------- | ---------------- | -------------- |
| 函数指针      | `int (*)(int, int)`        | 最原始，类型严格 | C兼容代码      |
| 函数对象      | 重载`operator()`           | 可携带状态       | 需要状态的算法 |
| Lambda        | `[](args){body}`           | 简洁，可捕获     | 局部简单逻辑   |
| std::function | `std::function<ret(args)>` | 类型擦除，通用   | 回调函数存储   |
| std::bind     | `std::bind(func, args)`    | 参数绑定/重排    | 适配接口       |



#### 9. 实际应用示例

```cpp
#include <iostream>
#include <functional>
#include <vector>

// 使用std::function作为回调函数类型
void registerCallback(std::function<void(int)> callback) {
    callback(42);  // 调用回调
}

int main() {
    // 1. 使用lambda作为回调
    registerCallback([](int value) {
        std::cout << "Lambda callback: " << value << std::endl;
    });

    // 2. 存储多种可调用对象
    std::vector<std::function<int(int, int)>> operations;
    operations.push_back([](int a, int b) { return a + b; });
    operations.push_back([](int a, int b) { return a * b; });
    
    for (auto& op : operations) {
        std::cout << op(3, 4) << std::endl;
    }

    // 3. 使用bind绑定参数
    auto greet = [](const std::string& name, int times) {
        for (int i = 0; i < times; ++i) {
            std::cout << "Hello, " << name << "!" << std::endl;
        }
    };
    
    auto sayHello = std::bind(greet, "World", 3);
    sayHello();  // 输出3次Hello, World!
}
```

C++11 的可调用对象机制大大增强了语言的表达能力和灵活性，为函数式编程风格和回调机制提供了强有力的支持。



## 十二. function可调用函数包装器

在 C++11 中，`std::function` 是一个通用的可调用对象包装器，它可以存储、复制和调用**任何可调用目标**（函数指针、lambda 表达式、函数对象等）。它是 `<functional>` 头文件中的类模板，提供了一种类型安全的、统一的方式来处理各种可调用对象。

---

### **基本用法**
#### 1. **声明格式**
```cpp
#include <functional>

std::function<返回值类型(参数类型列表)> 对象名;
```
例如：
```cpp
std::function<int(int, int)> func;  // 包装一个返回int、接受两个int参数的函数
```

---

#### 2. **包装不同类型的目标**
##### (1) **普通函数**
```cpp
int Add(int a, int b) { return a + b; }

std::function<int(int, int)> func = Add;
std::cout << func(3, 4);  // 输出 7
```

##### (2) **Lambda 表达式**
```cpp
auto lambda = [](int a, int b) { return a * b; };
std::function<int(int, int)> func = lambda;
std::cout << func(3, 4);  // 输出 12
```

##### (3) **函数对象（重载了 `operator()` 的类）**
```cpp
struct Multiplier {
    int operator()(int a, int b) const { return a * b; }
};

Multiplier mul;
std::function<int(int, int)> func = mul;
std::cout << func(3, 4);  // 输出 12
```

##### (4) **成员函数**（需结合 `std::bind`）
```cpp
class Math {
public:
    int Add(int a, int b) { return a + b; }
};

Math math;
// 绑定对象和成员函数
auto bound_func = std::bind(&Math::Add, &math, std::placeholders::_1, std::placeholders::_2);
std::function<int(int, int)> func = bound_func;
std::cout << func(3, 4);  // 输出 7
```

---

### **实际应用场景**
#### 1. **作为回调函数参数**
```cpp
#include <functional>
#include <vector>

// 定义一个接受回调的函数
void ProcessData(const std::vector<int>& data, std::function<void(int)> callback) {
    for (int num : data) {
        callback(num);
    }
}

int main() {
    std::vector<int> data = {1, 2, 3, 4};
    
    // 使用 Lambda 作为回调
    ProcessData(data, [](int num) {
        std::cout << num * 2 << " ";  // 输出 2 4 6 8
    });
}
```

#### 2. **存储回调列表**
```cpp
#include <functional>
#include <vector>

std::vector<std::function<void()>> callbacks;

void RegisterCallback(std::function<void()> func) {
    callbacks.push_back(func);
}

int main() {
    RegisterCallback([]() { std::cout << "Hello "; });
    RegisterCallback([]() { std::cout << "World!\n"; });

    for (auto& func : callbacks) {
        func();  // 依次输出 Hello World!
    }
}
```

---

### **注意事项**
1. **空指针检查**  
   调用空的 `std::function` 会抛出 `std::bad_function_call` 异常：
   ```cpp
   std::function<void()> empty_func;
   if (empty_func) {  // 检查是否为空
       empty_func();
   } else {
       std::cout << "Function is empty!\n";
   }
   ```

2. **性能**  
   `std::function` 有一定性能开销（类型擦除、虚函数调用），在性能敏感场景需谨慎使用。

3. **与模板的对比**  
   - **模板**：编译时多态，性能更高，但类型必须在编译时确定。
   - **`std::function`**：运行时多态，类型灵活，但有额外开销。

4. **绑定成员函数**  
   必须显式绑定对象实例（使用 `std::bind` + `this` 或对象指针）：
   ```cpp
   class Button {
   public:
       void onClick() { std::cout << "Button clicked!\n"; }
   };
   
   Button btn;
   auto callback = std::bind(&Button::onClick, &btn);
   std::function<void()> func = callback;
   func();  // 输出 "Button clicked!"
   ```

---

### **总结**
`std::function` 的核心价值在于提供了一种**类型安全的统一接口**，可以方便地处理各种可调用对象。它的典型应用场景包括：

| 场景          | 示例                       |
| ------------- | -------------------------- |
| 回调函数      | 事件处理、异步任务完成通知 |
| 策略模式      | 动态切换算法实现           |
| 命令模式      | 封装操作请求               |
| 函数表/分发器 | 根据条件调用不同函数       |

通过 `std::function`，C++ 实现了类似其他语言（如 Python、JavaScript）的“函数是一等公民”特性，极大地增强了代码的灵活性和表现力。



## 十三. bind绑定器的用法

`std::bind` 是 C++11 引入的函数适配器，用于**绑定参数**、**重新排列参数顺序**或**部分应用函数**。它位于 `<functional>` 头文件中，常用于创建灵活的回调机制。

---

## 基本语法

```cpp
#include <functional>

auto new_callable = std::bind(callable, arg_list);
```

- **`callable`**：可调用对象（函数、函数指针、成员函数、函数对象、lambda等）
- **`arg_list`**：参数列表，可以是具体值或占位符 `_1, _2, ..., _N`

---

## 核心功能

### 1. 绑定普通函数

```cpp
int add(int a, int b) { return a + b; }

// 绑定 add 的第一个参数为 10
auto add_10 = std::bind(add, 10, std::placeholders::_1);
std::cout << add_10(5);  // 输出 15 (10 + 5)
```

### 2. 重新排列参数顺序

```cpp
void print(int a, double b, const std::string& c) {
    std::cout << a << ", " << b << ", " << c << std::endl;
}

// 重新排列参数顺序：原函数参数顺序是 (int, double, string)
auto reordered = std::bind(print, 
    std::placeholders::_2,  // 原第2个参数 (double) → 新第1个参数
    std::placeholders::_1,  // 原第1个参数 (int)    → 新第2个参数
    "Fixed"                 // 固定第3个参数
);

reordered(3.14, 10);  // 输出 "10, 3.14, Fixed"
```

### 3. 绑定成员函数

```cpp
class MyClass {
public:
    void show(int x, const std::string& msg) {
        std::cout << x << ": " << msg << std::endl;
    }
};

MyClass obj;

// 绑定成员函数（需传递对象指针/引用）
auto bound_member = std::bind(
    &MyClass::show, 
    &obj,                     // 对象指针
    std::placeholders::_1,    // 第一个参数 → x
    "Hello"                   // 固定第二个参数
);

bound_member(42);  // 输出 "42: Hello"
```

### 4. 绑定函数对象

```cpp
struct Multiplier {
    int operator()(int a, int b) const { return a * b; }
};

Multiplier mul;
auto bound_functor = std::bind(mul, 10, std::placeholders::_1);
std::cout << bound_functor(5);  // 输出 50 (10 * 5)
```

---

## 占位符（Placeholders）

`std::placeholders::_1, _2, ..., _N` 表示新可调用对象的参数位置：

| 占位符 | 对应新调用时的参数位置 |
| ------ | ---------------------- |
| `_1`   | 第1个参数              |
| `_2`   | 第2个参数              |
| `...`  | ...                    |

```cpp
void func(int a, double b, const char* c) { /*...*/ }

// 绑定后参数顺序变为 (c, a, b)
auto f = std::bind(func, 
    std::placeholders::_2,  // 原a ← 新第2个参数
    std::placeholders::_3,  // 原b ← 新第3个参数
    std::placeholders::_1   // 原c ← 新第1个参数
);

f("Test", 10, 3.14);  // 实际调用 func(10, 3.14, "Test")
```

---

## 实际应用场景

### 1. 回调函数适配

```cpp
void onEvent(int eventId, const std::string& data) {
    std::cout << "Event " << eventId << ": " << data << std::endl;
}

// 绑定固定 eventId = 1001
auto callback = std::bind(onEvent, 1001, std::placeholders::_1);

// 只需要传递 data 参数
callback("Error occurred");  // 输出 "Event 1001: Error occurred"
```

### 2. STL 算法参数绑定

```cpp
std::vector<int> nums = {1, 2, 3, 4, 5};

// 查找第一个大于3的元素
auto it = std::find_if(
    nums.begin(), 
    nums.end(),
    std::bind(std::greater<int>(), std::placeholders::_1, 3)
);

if (it != nums.end()) {
    std::cout << *it;  // 输出 4
}
```

### 3. 多参数函数的部分应用

```cpp
double power(double base, double exponent) {
    return std::pow(base, exponent);
}

// 创建平方函数（固定 exponent = 2）
auto square = std::bind(power, std::placeholders::_1, 2);
std::cout << square(5);  // 输出 25 (5^2)
```

---

## 注意事项

1. **引用参数**：默认按值捕获，需用 `std::ref` 或 `std::cref` 传递引用
   ```cpp
   int x = 10;
   auto foo = std::bind([](int& a) { a *= 2; }, std::ref(x));
   foo();
   std::cout << x;  // 输出 20
   ```

2. **绑定智能指针**：避免对象生命周期问题
   ```cpp
   auto obj = std::make_shared<MyClass>();
   auto f = std::bind(&MyClass::show, obj, _1, "Hello");
   ```

3. **性能**：`std::bind` 会生成新的函数对象，可能有轻微运行时开销

4. **与 lambda 对比**：
   - **`std::bind`**：适合简单参数绑定/重排
   - **lambda**：更灵活，适合复杂逻辑

---

## C++11 与 C++14/17 的改进

### C++14 后推荐使用 lambda 替代简单绑定
```cpp
// 用 lambda 替代 std::bind
auto add_10 = [](int b) { return add(10, b); };
```

### C++17 引入 `std::invoke` 更通用调用方式

---

## 总结

`std::bind` 的核心功能：

| 功能         | 示例                           |
| ------------ | ------------------------------ |
| 参数绑定     | `bind(f, 10, _1)`              |
| 参数顺序重排 | `bind(f, _2, _1)`              |
| 成员函数绑定 | `bind(&Class::func, &obj, _1)` |
| 部分应用函数 | 固定部分参数，延迟执行         |

虽然现代 C++ 更推荐使用 lambda，但 `std::bind` 在需要**参数重排**或与**旧代码兼容**时仍有其价值。



## 十四. lambda函数的用法

在 C++11 及更高版本中，**lambda 表达式**是一种定义匿名函数对象的简洁方式，常用于需要临时函数逻辑的场景（如 STL 算法、回调函数等）。以下是 lambda 的详细用法：

---

### **基本语法**
```cpp
[捕获列表] (参数列表) -> 返回类型 { 
    函数体 
}
```
- **捕获列表**：定义如何捕获外部变量（可选）
- **参数列表**：函数的参数（可选）
- **返回类型**：可显式指定或自动推导（可选）
- **函数体**：具体实现逻辑

#### 示例
```cpp
// 无参数、无返回值的 lambda
auto hello = [] { 
    std::cout << "Hello, Lambda!"; 
};
hello();  // 输出 "Hello, Lambda!"
```

---

### **捕获外部变量**
#### 1. **捕获方式**
| 捕获方式         | 语法示例   | 说明                          |
| ---------------- | ---------- | ----------------------------- |
| **不捕获**       | `[]`       | 不访问任何外部变量            |
| **值捕获**       | `[x, y]`   | 复制外部变量 x、y 的值        |
| **引用捕获**     | `[&x, &y]` | 通过引用访问外部变量 x、y     |
| **隐式值捕获**   | `[=]`      | 自动值捕获所有外部变量        |
| **隐式引用捕获** | `[&]`      | 自动引用捕获所有外部变量      |
| **混合捕获**     | `[=, &x]`  | 除 x 为引用捕获外，其他值捕获 |

#### 2. **示例**
```cpp
int a = 10, b = 20;

// 值捕获 a，引用捕获 b
auto lambda1 = [a, &b] { 
    return a + b;  // a 是副本，b 是引用
};

// 隐式值捕获所有外部变量
auto lambda2 = [=] { 
    return a + b; 
};

// 隐式引用捕获所有外部变量
auto lambda3 = [&] { 
    a++;  // 修改原始变量 a
    return a + b; 
};
```

---

### **参数与返回值**
#### 1. **参数列表**
```cpp
// 接受两个 int 参数的 lambda
auto add = [](int x, int y) { 
    return x + y; 
};
std::cout << add(3, 4);  // 输出 7
```

#### 2. **返回类型**
- **自动推导**：若函数体只有单一 `return` 语句，可省略返回类型。
- **显式指定**：复杂逻辑需显式指定。
```cpp
// 显式指定返回类型为 double
auto divide = [](int x, int y) -> double {
    if (y == 0) return 0.0;
    return static_cast<double>(x) / y;
};
```

---

### **mutable 关键字**
- **默认**：值捕获的变量在 lambda 内是 `const`（不可修改）。
- **使用 `mutable`**：允许修改值捕获的变量（副本）。
```cpp
int count = 0;
auto increment = [count]() mutable {
    count++;  // 修改副本
    return count;
};
increment();  // 返回 1（副本被修改）
std::cout << count;  // 原 count 仍为 0
```

---

### **实际应用场景**
#### 1. **STL 算法**
```cpp
#include <vector>
#include <algorithm>

std::vector<int> nums = {3, 1, 4, 1, 5};

// 使用 lambda 排序（降序）
std::sort(nums.begin(), nums.end(), [](int a, int b) {
    return a > b;
});

// 使用 lambda 过滤偶数
auto it = std::remove_if(nums.begin(), nums.end(), [](int x) {
    return x % 2 == 0;
});
nums.erase(it, nums.end());
```

#### 2. **异步任务（多线程）**
```cpp
#include <thread>
#include <iostream>

int main() {
    int value = 100;
    // 在子线程中修改 value（需引用捕获）
    std::thread t([&value] {
        value *= 2;
    });
    t.join();
    std::cout << value;  // 输出 200
    return 0;
}
```

#### 3. **回调函数**
```cpp
#include <functional>

void process(std::function<void(int)> callback) {
    callback(42);
}

int main() {
    process([](int result) {
        std::cout << "Result: " << result;  // 输出 Result: 42
    });
    return 0;
}
```

---

### **注意事项**
1. **生命周期问题**  
   - **引用捕获**可能导致悬垂引用（变量被销毁后访问）。
   - **值捕获**保存的是捕获时的值（后续外部变量修改不影响副本）。

2. **性能优化**  
   - 简单的 lambda 通常会被编译器内联优化。
   - 复杂的 lambda 可能生成闭包对象，带来额外开销。

3. **类型唯一性**  
   - 每个 lambda 表达式生成唯一的匿名类型。
   - 使用 `auto` 或 `std::function` 存储 lambda。

4. **C++14/17 扩展**  
   - **泛型 lambda**：参数使用 `auto`。
     ```cpp
     auto print = [](auto x) { 
         std::cout << x; 
     };
     print(10);   // int
     print(3.14); // double
     ```
   - **捕获表达式**：初始化捕获变量（C++14）。
     ```cpp
     int x = 10;
     auto lambda = [y = x + 5] { 
         return y;  // y = 15
     };
     ```

---

### **总结**
**lambda 表达式**的核心优势：

| 场景               | 示例                         |
| ------------------ | ---------------------------- |
| 简化 STL 算法      | `std::sort`, `std::for_each` |
| 快速定义回调       | 事件处理、异步任务           |
| 避免定义函数对象类 | 临时逻辑封装                 |
| 闭包封装状态       | 携带局部变量的函数           |

通过 lambda，C++ 可以更简洁地实现函数式编程范式，提升代码的可读性和灵活性。



## 十五. C++中的右值与右值引用

右值(Rvalue)和右值引用(Rvalue Reference)是C++11引入的重要概念，它们为移动语义和完美转发提供了基础支持，极大地提高了C++程序的效率。

## 右值(Rvalue)

### 1. 基本概念
右值是指**临时对象**或**即将被销毁的对象**，它们不能被取地址。右值主要包括：
- 字面量(如`42`、`"hello"`)
- 临时对象(如函数返回的临时对象)
- 表达式计算结果(如`x + y`)

### 2. 右值的特点
- 通常没有名称
- 生命周期短暂
- 不能被取地址(`&`操作符)
- 只能出现在赋值运算符的右侧

### 3. 右值示例
```cpp
int a = 42;       // 42是右值
std::string s = "hello";  // "hello"是右值

int x = 1, y = 2;
int z = x + y;    // x+y的结果是右值

std::string getName() { return "Alice"; }
std::string name = getName();  // getName()返回的是右值
```

## 右值引用(Rvalue Reference)

### 1. 基本概念
右值引用是C++11引入的新引用类型，使用`&&`表示，它**只能绑定到右值**。

C++11中引用折叠的规则如下：

1. 通过右值推导T&&或者auto&&得到的是一个右值引用类型
2. 通过非右值（右值引用，左值，左值引用，常量右值引用，常量左值引用）推导T&&或者auto&&得到的是一个左值引用类型

### 2. 语法形式
```cpp
Type&& variable = rvalue;
```

### 3. 右值引用的特点
- 只能绑定到右值，不能绑定到左值
- 延长了临时对象的生命周期
- 是实现移动语义的基础

### 4. 右值引用示例
```cpp
int&& r1 = 42;        // 正确：42是右值
int x = 10;
int&& r2 = x;         // 错误：x是左值，不能绑定到右值引用

std::string&& s1 = std::string("temp");  // 正确：临时对象是右值
std::string name = "Alice";
std::string&& s2 = name;                 // 错误：name是左值
```

### 5. 注意事项

1. 左值和右值是独立于他们类型的，右值引用类型可能是左值也可能是右值
2. 编译器会将以命名的右值引用视为左值，将未命名的右值引用视为右值
3. auto&&或者函数参数类型自动推导的T&&是一个未定的引用类型，它可能是左值引用也可能是右值引用类型，这取决于初始化的值类型
4. 通过右值推导T&& 或者auto&&得到的是一个右值引用类型，其余都是左值引用类型

## 移动语义(Move Semantics)

### 1. `std::move`函数
`std::move`可以将左值转换为右值引用，表示"我允许你移动这个对象的内容"。

```cpp
std::string str1 = "Hello";
std::string str2 = std::move(str1);  // 移动构造，str1现在为空
```

### 2. 移动构造函数和移动赋值运算符
```cpp
class MyString {
public:
    // 移动构造函数
    MyString(MyString&& other) noexcept 
        : data(other.data), size(other.size) {
        other.data = nullptr;  // 置空原对象指针
        other.size = 0;
    }
    
    // 移动赋值运算符
    MyString& operator=(MyString&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            size = other.size;
            other.data = nullptr;
            other.size = 0;
        }
        return *this;
    }
    
private:
    char* data;
    size_t size;
};
```

## 完美转发(Perfect Forwarding)

### 1. 通用引用(Universal Reference)
使用`auto&&`或模板参数`T&&`可以接受左值或右值。

```cpp
template<typename T>
void func(T&& arg) {  // arg是通用引用
    // ...
}
```

### 2. `std::forward`函数
保持参数原始的左值/右值属性进行转发。

```cpp
template<typename T>
void wrapper(T&& arg) {
    // 完美转发arg
    some_function(std::forward<T>(arg));
}
```

## 右值引用的应用场景

1. **实现高效的移动语义**
   - 避免深拷贝大型对象
   - 提高容器操作的效率

2. **优化临时对象处理**
   - 减少不必要的拷贝构造

3. **实现完美转发**
   - 保持参数的原始值类别

4. **标准库中的应用**
   - `std::vector`的`push_back`有右值引用重载
   - 所有STL容器都支持移动语义

## 注意事项

1. 不要返回局部变量的右值引用
2. 被移动后的对象处于有效但未定义状态
3. 移动操作应标记为`noexcept`以便标准库优化
4. 移动语义不是万能的，某些类型(如基本类型)移动并不比拷贝快



## 十六. std::move和std::forward详解

`std::move`和`std::forward`是C++11引入的两个重要工具函数，它们都与右值引用相关，但在用途和工作原理上有本质区别。

## std::move

### 1. 基本功能
`std::move`用于将对象**无条件转换**为右值引用，表示"这个对象可以被移动"。

### 2. 实现原理
```cpp
template <typename T>
typename std::remove_reference<T>::type&& move(T&& t) noexcept {
    return static_cast<typename std::remove_reference<T>::type&&>(t);
}
```

### 3. 关键特点
- **无条件转换**：无论输入是左值还是右值，都转换为右值引用
- **不移动任何东西**：只是类型转换，真正的移动操作由移动构造函数/赋值运算符完成
- **标记作用**：告诉编译器这个对象可以被移动

### 4. 使用场景
```cpp
std::string str1 = "Hello";
std::string str2 = std::move(str1); // 调用移动构造函数

std::vector<int> v1 = {1, 2, 3};
std::vector<int> v2 = std::move(v1); // 调用移动赋值运算符
```

### 5. 注意事项
- 被move后的对象处于**有效但未指定状态**
- 基本类型(int, float等)使用move不会有性能提升
- 移动后应避免继续使用原对象，除非重新赋值

## std::forward

### 1. 基本功能
`std::forward`用于**有条件转换**，保持参数的原始值类别(左值/右值)，实现完美转发。

注意事项：

1. 当T为左值引用类型时，t将被转换为T类型的左值
2. 当T不是左值引用类型时，t将被转换为T类型的右值

### 2. 实现原理
```cpp
template <typename T>
T&& forward(typename std::remove_reference<T>::type& t) noexcept {
    return static_cast<T&&>(t);
}

template <typename T>
T&& forward(typename std::remove_reference<T>::type&& t) noexcept {
    return static_cast<T&&>(t);
}
```

### 3. 关键特点
- **有条件转换**：根据模板参数T决定转换为何种引用
- **保持值类别**：左值转发后仍是左值，右值转发后仍是右值
- **完美转发**：与通用引用(T&&)配合使用，实现参数完美传递

### 4. 使用场景
```cpp
template <typename T>
void wrapper(T&& arg) {
    // 完美转发arg，保持其原始值类别
    some_function(std::forward<T>(arg));
}

wrapper(42);             // 转发右值
int x = 10;
wrapper(x);              // 转发左值
wrapper(std::move(x));   // 转发右值
```

### 5. 注意事项
- 必须与通用引用(T&&)一起使用
- 主要用于模板函数中转发参数
- 保持参数的值类别和const属性

## 对比总结

| 特性             | std::move            | std::forward                |
| ---------------- | -------------------- | --------------------------- |
| **用途**         | 无条件转换为右值引用 | 有条件保持值类别            |
| **转换类型**     | 总是转为右值引用     | 根据T决定左值/右值引用      |
| **主要应用场景** | 移动语义             | 完美转发                    |
| **参数要求**     | 接受任何类型         | 必须与通用引用(T&&)配合使用 |
| **是否实际移动** | 否，只是类型转换     | 否，只是类型转换            |
| **头文件**       | <utility>            | <utility>                   |

## 代码示例

### 1. std::move示例
```cpp
class Resource {
    int* data;
public:
    // 移动构造函数
    Resource(Resource&& other) noexcept 
        : data(other.data) {
        other.data = nullptr;
    }
    
    // 移动赋值运算符
    Resource& operator=(Resource&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};

Resource a;
Resource b = std::move(a); // 调用移动构造函数
```

### 2. std::forward示例
```cpp
void process(int& x) { std::cout << "lvalue\n"; }
void process(int&& x) { std::cout << "rvalue\n"; }

template <typename T>
void logAndProcess(T&& param) {
    // 记录日志...
    process(std::forward<T>(param)); // 完美转发
}

int main() {
    int x = 10;
    logAndProcess(x);        // 输出"lvalue"
    logAndProcess(20);       // 输出"rvalue"
    logAndProcess(std::move(x)); // 输出"rvalue"
}
```

## 最佳实践

1. **使用std::move时**：
   - 明确知道对象不再需要当前值
   - 在返回局部对象时使用可以优化
   ```cpp
   std::vector<int> createVector() {
       std::vector<int> v {1, 2, 3};
       return std::move(v); // 允许但不必要，编译器会优化(NRVO)
   }
   ```

2. **使用std::forward时**：
   - 在通用引用模板函数中转发参数
   - 保持工厂函数和包装器的参数传递效率
   ```cpp
   template <typename... Args>
   auto make_unique(Args&&... args) {
       return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
   }
   ```

3. **避免滥用**：
   - 不要对基本类型使用move(无性能提升)
   - 不要对已经移动的对象再次使用
   - 确保移动后的对象处于有效状态



## 十七. C++11智能指针

C++11引入的智能指针是内存管理的一大进步，解决了手动内存管理容易出现的内存泄漏和悬挂指针等问题。主要有三种智能指针：`std::unique_ptr`、`std::shared_ptr`和`std::weak_ptr`，都定义在`<memory>`头文件中。

## 1. std::unique_ptr

`unique_ptr`实现独占所有权语义，即同一时间只能有一个`unique_ptr`指向特定对象。

### 特点：
- 轻量级，几乎没有运行时开销
- 不允许复制，只能移动
- 当`unique_ptr`销毁时，其管理的对象也自动销毁

### 用法：

```cpp
#include <memory>
#include <iostream>

// 创建unique_ptr
std::unique_ptr<int> p1(new int(5));
auto p2 = std::make_unique<int>(10);  // C++14引入

// 移动所有权
std::unique_ptr<int> p3 = std::move(p1);  // p1现在为nullptr

// 访问资源
std::cout << *p2 << std::endl;  // 输出10
std::cout << *p3 << std::endl;  // 输出5

// 释放所有权
p3.reset();  // 显式释放
// *p3 会导致未定义行为，因为p3现在是nullptr

// 自定义删除器
auto deleter = [](int* p) { 
    std::cout << "自定义删除器" << std::endl;
    delete p; 
};
std::unique_ptr<int, decltype(deleter)> p4(new int(20), deleter);
```

## 2. std::shared_ptr

`shared_ptr`实现共享所有权语义，多个`shared_ptr`可以指向同一个对象，对象在最后一个引用它的`shared_ptr`销毁时才被删除。

### 特点：
- 使用引用计数跟踪共享对象
- 允许复制
- 有轻微的运行时开销（引用计数的管理）

### 用法：

```cpp
#include <memory>
#include <iostream>

// 创建shared_ptr
std::shared_ptr<int> sp1(new int(100));
auto sp2 = std::make_shared<int>(200);  // 推荐用法，更高效

// 复制shared_ptr
std::shared_ptr<int> sp3 = sp1;  // 引用计数+1

// 检查引用计数
std::cout << "sp1引用计数: " << sp1.use_count() << std::endl;  // 输出2

// 访问资源
std::cout << *sp1 << std::endl;  // 输出100
std::cout << *sp3 << std::endl;  // 输出100

// 释放引用
sp1.reset();  // sp1变为nullptr，引用计数-1
std::cout << "sp3引用计数: " << sp3.use_count() << std::endl;  // 输出1

// 自定义删除器
auto sharedDeleter = [](int* p) {
    std::cout << "shared_ptr自定义删除器" << std::endl;
    delete p;
};
std::shared_ptr<int> sp4(new int(300), sharedDeleter);
```

## 3. std::weak_ptr

`weak_ptr`是`shared_ptr`的附属品，它观察但不拥有对象，不影响对象的生命周期。主要用于解决`shared_ptr`可能形成的循环引用问题。

### 特点：
- 不增加引用计数
- 不能直接访问对象，必须先转换为`shared_ptr`
- 可以检测对象是否已被销毁

### 用法：

```cpp
#include <memory>
#include <iostream>

// 创建shared_ptr
auto sp = std::make_shared<int>(42);

// 创建weak_ptr观察sp
std::weak_ptr<int> wp = sp;

// 检查引用计数 (不受weak_ptr影响)
std::cout << "引用计数: " << sp.use_count() << std::endl;  // 输出1

// 使用weak_ptr:
if (auto temp = wp.lock()) {  // 转换为shared_ptr
    std::cout << "对象仍存在: " << *temp << std::endl;
} else {
    std::cout << "对象已销毁" << std::endl;
}

// 销毁shared_ptr
sp.reset();

// 再次尝试使用weak_ptr
if (auto temp = wp.lock()) {
    std::cout << "对象仍存在: " << *temp << std::endl;
} else {
    std::cout << "对象已销毁" << std::endl;  // 输出这行
}

// 检查weak_ptr是否过期
std::cout << "weak_ptr已过期: " << wp.expired() << std::endl;  // 输出1(true)
```

## 4. 循环引用问题及解决方案

当两个或多个`shared_ptr`相互引用时，会形成循环引用，导致内存泄漏：

```cpp
struct Node {
    std::shared_ptr<Node> next;
    ~Node() { std::cout << "Node销毁" << std::endl; }
};

void circularReference() {
    auto node1 = std::make_shared<Node>();
    auto node2 = std::make_shared<Node>();
    
    // 创建循环引用
    node1->next = node2;
    node2->next = node1;
    
    // 函数结束后，node1和node2的引用计数都为2
    // 它们永远不会被销毁，造成内存泄漏
}
```

解决方法是使用`weak_ptr`打破循环：

```cpp
struct NodeFixed {
    std::weak_ptr<NodeFixed> next;  // 使用weak_ptr
    ~NodeFixed() { std::cout << "NodeFixed销毁" << std::endl; }
};

void noCircularReference() {
    auto node1 = std::make_shared<NodeFixed>();
    auto node2 = std::make_shared<NodeFixed>();
    
    // 不会形成循环引用
    node1->next = node2;
    node2->next = node1;
    
    // 函数结束后，对象会正常销毁
}
```

## 5. 智能指针的最佳实践

- 使用`make_shared`和`make_unique`而不是直接用`new`
- 避免将普通指针转换为智能指针多次
- 使用`unique_ptr`作为默认选择，只在需要共享所有权时使用`shared_ptr`
- 使用`weak_ptr`解决循环引用问题
- 不要对同一个原始指针创建多个智能指针
- 智能指针尽量作为栈对象使用，不要用`new`创建智能指针对象

```cpp
// 错误示范
int* rawPtr = new int(10);
std::shared_ptr<int> sp1(rawPtr);
std::shared_ptr<int> sp2(rawPtr);  // 错误！会导致双重释放

// 正确做法
auto sp1 = std::make_shared<int>(10);
auto sp2 = sp1;  // 通过复制shared_ptr共享所有权
```

智能指针是现代C++内存管理的核心工具，正确使用它们可以有效避免内存泄漏和提高代码安全性。